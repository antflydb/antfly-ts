/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/status": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get cluster status
         * @description Returns the current health and status of all stores and shards in the cluster
         */
        get: operations["getStatus"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/query": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Perform a global query
         * @description Executes a query across all relevant tables and shards based on the query content.
         *
         *     ## Query Examples
         *
         *     **Full-text search:**
         *     ```json
         *     {
         *       "table": "wikipedia",
         *       "full_text_search": {"query": "body:computer"},
         *       "limit": 10
         *     }
         *     ```
         *
         *     **Semantic search:**
         *     ```json
         *     {
         *       "table": "articles",
         *       "semantic_search": "artificial intelligence applications",
         *       "indexes": ["title_body_embedding"],
         *       "limit": 20
         *     }
         *     ```
         *
         *     **Hybrid search (RRF):**
         *     ```json
         *     {
         *       "table": "products",
         *       "full_text_search": {"query": "laptop gaming"},
         *       "semantic_search": "high performance gaming computers",
         *       "indexes": ["product_embedding"],
         *       "filter_query": {"query": "price:<2000 AND in_stock:true"},
         *       "fields": ["name", "price", "description"],
         *       "limit": 15
         *     }
         *     ```
         *
         *     **With filtering:**
         *     ```json
         *     {
         *       "table": "users",
         *       "filter_prefix": "tenant:acme:",
         *       "full_text_search": {"query": "active:true"},
         *       "exclusion_query": {"query": "status:deleted"},
         *       "limit": 50
         *     }
         *     ```
         *
         *     **NDJSON format:**
         *     For bulk queries, send multiple queries as NDJSON with `Content-Type: application/x-ndjson`.
         *     Each line must end with `\n`:
         *     ```
         *     {"table":"wiki","semantic_search":"AI","indexes":["emb"],"limit":5}
         *     {"table":"docs","full_text_search":{"query":"tutorial"},"limit":10}
         *     ```
         */
        post: operations["globalQuery"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/rag": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Perform RAG (Retrieval-Augmented Generation) query
         * @description Executes a query and streams a summary of the results using the specified summarizer. The response is streamed as Server-Sent Events (SSE) for real-time updates.
         */
        post: operations["ragQuery"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/agents/answer": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Answer Agent - Intelligent query routing with automatic query generation
         * @description Uses LLM to classify and improve the query, transform it for optimal semantic search, execute the provided queries with the transformed text, and generate an answer. Streams classification, query execution, results, and answer as SSE events.
         */
        post: operations["answerAgent"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/tables": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List all tables */
        get: operations["listTables"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/tables/{tableName}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the table */
                tableName: string;
            };
            cookie?: never;
        };
        /** Get table details */
        get: operations["getTable"];
        put?: never;
        /**
         * Create a new table
         * @description Creates a new table with optional schema definition, indexes, and configuration.
         *
         *     ## Use Cases
         *
         *     **Simple table for unstructured data:**
         *     ```json
         *     {
         *       "num_shards": 1
         *     }
         *     ```
         *
         *     **Table with full-text search:**
         *     ```json
         *     {
         *       "num_shards": 3,
         *       "schema": {
         *         "document_schemas": {
         *           "article": {
         *             "schema": {
         *               "type": "object",
         *               "properties": {
         *                 "id": {
         *                   "type": "string",
         *                   "x-antfly-types": ["keyword"]
         *                 },
         *                 "title": {
         *                   "type": "string",
         *                   "x-antfly-types": ["text", "keyword"]
         *                 },
         *                 "body": {
         *                   "type": "string",
         *                   "x-antfly-types": ["text"]
         *                 }
         *               },
         *               "x-antfly-include-in-all": ["title", "body"]
         *             }
         *           }
         *         },
         *         "default_type": "article"
         *       },
         *       "indexes": {
         *         "search_idx": {
         *           "type": "full_text_v0"
         *         }
         *       }
         *     }
         *     ```
         *
         *     **Table with vector similarity search:**
         *     ```json
         *     {
         *       "num_shards": 5,
         *       "description": "Product catalog with semantic search",
         *       "schema": {
         *         "document_schemas": {
         *           "product": {
         *             "schema": {
         *               "type": "object",
         *               "properties": {
         *                 "product_id": {
         *                   "type": "string",
         *                   "x-antfly-types": ["keyword"]
         *                 },
         *                 "name": {
         *                   "type": "string",
         *                   "x-antfly-types": ["text", "keyword"]
         *                 },
         *                 "description": {
         *                   "type": "string",
         *                   "x-antfly-types": ["text"]
         *                 },
         *                 "price": {
         *                   "type": "number",
         *                   "x-antfly-types": ["numeric"]
         *                 }
         *               },
         *               "x-antfly-include-in-all": ["name", "description"]
         *             }
         *           }
         *         },
         *         "default_type": "product"
         *       },
         *       "indexes": {
         *         "semantic_idx": {
         *           "type": "aknn_v0",
         *           "field": "description",
         *           "embedder": {
         *             "provider": "ollama",
         *             "model": "all-minilm",
         *             "url": "http://localhost:11434"
         *           }
         *         }
         *       }
         *     }
         *     ```
         *
         *     ## Best Practices
         *
         *     - Define schema for core fields to improve performance
         *     - Start with fewer shards for small datasets (1-3)
         *     - Use meaningful table names (e.g., "products", "users", "articles")
         *     - Consider adding both full-text and vector indexes for hybrid search
         */
        post: operations["createTable"];
        /** Drop a table */
        delete: operations["dropTable"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/tables/{tableName}/query": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the table to query */
                tableName: string;
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Query a specific table */
        post: operations["queryTable"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/tables/{tableName}/rag": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the table for RAG query */
                tableName: string;
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Perform RAG query on a specific table
         * @description Executes a RAG query on a specific table and streams a summary of the results using the specified summarizer. The response is streamed as Server-Sent Events (SSE) for real-time updates or returns JSON with citations.
         */
        post: operations["tableRagQuery"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/tables/{tableName}/batch": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the table for batch operation */
                tableName: string;
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Perform batch inserts and deletes on a table */
        post: operations["batch"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/tables/{tableName}/merge": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the table */
                tableName: string;
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Linear merge sorted records from external source
         * @description Performs a stateless linear merge of sorted records from an external source.
         *     Records are upserted, and any Antfly records in the key range that are absent
         *     from the input are deleted. Supports progressive pagination for large datasets.
         *
         *     WARNING: Not safe for concurrent merge operations with overlapping ranges.
         *     Designed as a sync/import API for single-client use.
         */
        post: operations["linearMerge"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/tables/{tableName}/backup": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the table to backup */
                tableName: string;
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Backup a table */
        post: operations["backupTable"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/tables/{tableName}/restore": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the table to restore into */
                tableName: string;
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Restore a table from backup */
        post: operations["restoreTable"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/tables/{tableName}/schema": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the table */
                tableName: string;
            };
            cookie?: never;
        };
        get?: never;
        /** Update a table's schema */
        put: operations["updateSchema"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/tables/{tableName}/lookup/{key}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the table */
                tableName: string;
                /** @description Key of the record to lookup */
                key: string;
            };
            cookie?: never;
        };
        /** Lookup a key in a table */
        get: operations["lookupKey"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/tables/{tableName}/indexes": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the table */
                tableName: string;
            };
            cookie?: never;
        };
        /** List all indexes for a table */
        get: operations["listIndexes"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/tables/{tableName}/indexes/{indexName}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the table */
                tableName: string;
                /** @description Name of the index */
                indexName: string;
            };
            cookie?: never;
        };
        /** Get index details */
        get: operations["getIndex"];
        put?: never;
        /** Add an index to a table */
        post: operations["createIndex"];
        /** Drop an index from a table */
        delete: operations["dropIndex"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/me": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get current authenticated user
         * @description Retrieves details for the currently authenticated user.
         */
        get: operations["getCurrentUser"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List all users
         * @description Retrieves a list of all users in the system. Requires admin permission.
         */
        get: operations["listUsers"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/{userName}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The username. */
                userName: components["parameters"]["UserNamePathParameter"];
            };
            cookie?: never;
        };
        /**
         * Get user details
         * @description Retrieves details for a specific user.
         */
        get: operations["getUserByName"];
        put?: never;
        /**
         * Create a new user
         * @description Creates a new user with the given username and password. Username in path takes precedence.
         */
        post: operations["createUser"];
        /**
         * Delete a user
         * @description Deletes a specific user.
         */
        delete: operations["deleteUser"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/{userName}/password": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The username. */
                userName: components["parameters"]["UserNamePathParameter"];
            };
            cookie?: never;
        };
        get?: never;
        /**
         * Update user password
         * @description Updates the password for a specific user.
         */
        put: operations["updateUserPassword"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/{userName}/permissions": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The username. */
                userName: components["parameters"]["UserNamePathParameter"];
            };
            cookie?: never;
        };
        /**
         * Get user permissions
         * @description Retrieves all permissions for a specific user.
         */
        get: operations["getUserPermissions"];
        put?: never;
        /**
         * Add permission to user
         * @description Adds a new permission to a specific user.
         */
        post: operations["addPermissionToUser"];
        /**
         * Remove permission from user
         * @description Removes a specific permission rule from a user based on resource name and type.
         */
        delete: operations["removePermissionFromUser"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        Error: {
            /** @example An error message */
            error: string;
        };
        /**
         * @description Overall health status of the cluster
         * @enum {string}
         */
        ClusterHealth: "unknown" | "healthy" | "unhealthy" | "degraded" | "error";
        ClusterStatus: {
            health: components["schemas"]["ClusterHealth"];
            /** @description Optional message providing details about the health status */
            message?: string;
            /** @description Indicates whether authentication is enabled for the cluster */
            auth_enabled?: boolean;
        } & {
            [key: string]: unknown;
        };
        ByteRange: string[];
        /**
         * @description Synchronization level for batch operations:
         *     - "propose": Wait for Raft proposal acceptance (fastest, default)
         *     - "write": Wait for Pebble KV write
         *     - "full_text": Wait for full-text index WAL write
         *     - "enrichments": Pre-compute enrichments before Raft proposal (synchronous enrichment generation)
         *     - "aknn": Wait for vector index write with best-effort synchronous embedding (falls back to async on timeout, slowest, most durable)
         * @default propose
         * @enum {string}
         */
        SyncLevel: "propose" | "write" | "full_text" | "enrichments" | "aknn";
        ShardConfig: {
            byte_range: components["schemas"]["ByteRange"];
        };
        CreateTableRequest: {
            /**
             * Format: uint
             * @description Number of shards to create for the table. Data is partitioned across shards based on key ranges.
             *
             *     Guidelines:
             *     - Small datasets (<100K docs): 1-3 shards
             *     - Medium datasets (100K-1M docs): 3-10 shards
             *     - Large datasets (>1M docs): 10+ shards
             *
             *     More shards enable better parallelism but increase overhead. Choose based on expected data size and query patterns.
             * @example 3
             */
            num_shards?: number;
            /**
             * @description Optional human-readable description of the table and its purpose.
             *     Useful for documentation and team collaboration.
             * @example User profiles with embeddings for semantic search
             */
            description?: string;
            /**
             * @description Map of index name to index configuration. Indexes enable different query capabilities:
             *     - Full-text indexes for BM25 search
             *     - Vector indexes for semantic similarity
             *     - Multimodal indexes for images/audio/video
             *
             *     You can add multiple indexes to support different query patterns.
             * @example {
             *       "search_index": {
             *         "type": "full_text_v0"
             *       },
             *       "embedding_index": {
             *         "type": "aknn_v0",
             *         "dimension": 384,
             *         "embedder": {
             *           "provider": "ollama",
             *           "model": "all-minilm"
             *         }
             *       }
             *     }
             */
            indexes?: {
                [key: string]: components["schemas"]["IndexConfig"];
            };
            /**
             * @description Optional schema definition specifying field types and primary key.
             *     While optional, defining a schema provides type safety, optimized indexing, and better search performance.
             */
            schema?: components["schemas"]["TableSchema"];
        };
        /** @enum {string} */
        AntflyType: "search_as_you_type" | "keyword" | "text" | "html" | "numeric" | "datetime" | "boolean" | "link" | "geopoint" | "geoshape" | "embedding" | "blob";
        Table: {
            name: string;
            /**
             * @description Optional description of the table.
             * @example Table for user data
             */
            description?: string;
            indexes: {
                [key: string]: components["schemas"]["IndexConfig"];
            };
            shards: {
                [key: string]: components["schemas"]["ShardConfig"];
            };
            schema?: components["schemas"]["TableSchema"];
        };
        DateRange: {
            name: string;
            from?: string;
            to?: string;
        };
        NumericRange: {
            name: string;
            /** Format: float */
            from?: number;
            /** Format: float */
            to?: number;
        };
        TermFacetResult: {
            term: string;
            count: number;
        };
        DateRangeResult: components["schemas"]["DateRange"] & {
            count: number;
        };
        NumericRangeResult: components["schemas"]["NumericRange"] & {
            count: number;
        };
        FacetOption: {
            field?: string;
            size?: number;
            date_ranges?: components["schemas"]["DateRange"][];
            numeric_ranges?: components["schemas"]["NumericRange"][];
        };
        FacetResult: {
            field?: string;
            total?: number;
            missing?: number;
            terms?: components["schemas"]["TermFacetResult"][];
            date_ranges?: components["schemas"]["DateRangeResult"][];
            numeric_ranges?: components["schemas"]["NumericRangeResult"][];
        };
        IndexStatus: {
            shard_status: {
                [key: string]: components["schemas"]["IndexStats"];
            };
            config: components["schemas"]["IndexConfig"];
            status: components["schemas"]["IndexStats"];
        };
        StorageStatus: {
            /**
             * Format: uint64
             * @description Disk usage in bytes.
             */
            disk_usage?: number;
            /** @description Whether the table has received data. */
            empty?: boolean;
        };
        TableStatus: components["schemas"]["Table"] & {
            storage_status: components["schemas"]["StorageStatus"];
        };
        /**
         * @description MongoDB-style update operator
         * @enum {string}
         */
        TransformOpType: "$set" | "$unset" | "$inc" | "$push" | "$pull" | "$addToSet" | "$pop" | "$mul" | "$min" | "$max" | "$currentDate" | "$rename";
        TransformOp: {
            op: components["schemas"]["TransformOpType"];
            /**
             * @description JSONPath to field (e.g., "$.user.name", "$.tags", or "user.name")
             * @example $.views
             */
            path: string;
            /** @description Value for operation (not required for $unset, $currentDate). Type depends on operator (number for $inc/$mul, any for $set, etc.) */
            value?: unknown;
        };
        /**
         * @description In-place document transformation using MongoDB-style operators. Transforms are applied atomically
         *     at the storage layer, eliminating read-modify-write races.
         *
         *     **Important:** Transform results are NOT validated against the table schema. This improves performance
         *     but means it's possible to create invalid documents. Use with care and ensure your operations maintain
         *     schema compliance.
         * @example {
         *       "key": "article:123",
         *       "operations": [
         *         {
         *           "op": "$inc",
         *           "path": "$.views",
         *           "value": 1
         *         },
         *         {
         *           "op": "$currentDate",
         *           "path": "$.lastViewed"
         *         }
         *       ]
         *     }
         */
        Transform: {
            /** @description Document key (must be a string, not an object like inserts) */
            key: string;
            /** @description List of operations to apply in sequence */
            operations: components["schemas"]["TransformOp"][];
            /**
             * @description If true, create document if it doesn't exist (like MongoDB upsert)
             * @default false
             */
            upsert: boolean;
        };
        /**
         * @description Batch insert, delete, and transform operations in a single request. All operations are processed atomically within each shard.
         *
         *     Benefits:
         *     - Reduces network overhead compared to individual requests
         *     - More efficient indexing (updates are batched)
         *     - Atomic within shard boundaries
         *
         *     The inserts are upserts - existing keys are overwritten, new keys are created.
         * @example {
         *       "inserts": {
         *         "user:123": {
         *           "name": "John Doe",
         *           "email": "john@example.com",
         *           "age": 30,
         *           "tags": [
         *             "customer",
         *             "premium"
         *           ]
         *         },
         *         "user:456": {
         *           "name": "Jane Smith",
         *           "email": "jane@example.com",
         *           "age": 25,
         *           "tags": [
         *             "customer"
         *           ]
         *         }
         *       },
         *       "deletes": [
         *         "user:789",
         *         "user:old_account"
         *       ]
         *     }
         */
        BatchRequest: {
            /**
             * @description Map of document IDs to document objects. Each key is the unique identifier for the document.
             *
             *     Best practices:
             *     - Use consistent key naming schemes (e.g., "user:123", "article:456")
             *     - Key length affects storage and performance - keep them reasonably short
             *     - Keys are sorted lexicographically, so choose prefixes that support range scans
             * @example {
             *       "user:123": {
             *         "name": "John Doe",
             *         "email": "john@example.com",
             *         "age": 30,
             *         "tags": [
             *           "customer",
             *           "premium"
             *         ]
             *       },
             *       "user:456": {
             *         "name": "Jane Smith",
             *         "email": "jane@example.com",
             *         "age": 25,
             *         "tags": [
             *           "customer"
             *         ]
             *       }
             *     }
             */
            inserts?: {
                [key: string]: Record<string, never>;
            };
            /**
             * @description Array of document IDs to delete. Documents are removed from all indexes.
             *
             *     Notes:
             *     - Non-existent keys are silently ignored
             *     - Deletions are processed before inserts in the same batch
             *     - Keys are permanently removed from storage and indexes
             * @example [
             *       "user:789",
             *       "user:old_account"
             *     ]
             */
            deletes?: string[];
            /**
             * @description Array of transform operations for in-place document updates using MongoDB-style operators.
             *
             *     Transform operations allow you to modify documents without read-modify-write races:
             *     - Operations are applied atomically on the server
             *     - Multiple operations per document are applied in sequence
             *     - Supports numeric operations ($inc, $mul), array operations ($push, $pull), and more
             *
             *     Common use cases:
             *     - Increment counters (views, likes, votes)
             *     - Update timestamps ($currentDate)
             *     - Manage arrays (add/remove tags, items)
             *     - Update nested fields without overwriting the entire document
             * @example [
             *       {
             *         "key": "article:123",
             *         "operations": [
             *           {
             *             "op": "$inc",
             *             "path": "$.views",
             *             "value": 1
             *           },
             *           {
             *             "op": "$currentDate",
             *             "path": "$.lastViewed"
             *           }
             *         ]
             *       },
             *       {
             *         "key": "user:456",
             *         "operations": [
             *           {
             *             "op": "$push",
             *             "path": "$.tags",
             *             "value": "vip"
             *           }
             *         ]
             *       }
             *     ]
             */
            transforms?: components["schemas"]["Transform"][];
            sync_level?: components["schemas"]["SyncLevel"];
        };
        BackupRequest: {
            /**
             * @description Unique identifier for this backup. Used to reference the backup for restore operations.
             *     Choose a meaningful name that includes date/version information.
             * @example backup-2025-01-15-v2
             */
            backup_id: string;
            /**
             * @description Storage location for the backup. Supports multiple backends:
             *     - Local filesystem: `file:///path/to/backup`
             *     - Amazon S3: `s3://bucket-name/path/to/backup`
             *
             *     The backup includes all table data, indexes, and metadata for the specified table.
             * @example s3://mybucket/antfly-backups/users-table/2025-01-15
             */
            location: string;
        };
        RestoreRequest: components["schemas"]["BackupRequest"];
        RAGRequest: {
            /**
             * @description Array of retrieval queries to execute. Each query must specify a table and can specify its own limit and document_renderer.
             *     Results from all queries are concatenated together (respecting each query's limit).
             *     For single table: [{"table": "papers", "semantic_search": "...", "limit": 10}]
             *     For broadcast: [{"table": "images", "limit": 5, ...}, {"table": "products", "limit": 5, ...}]
             *     For mixed: [{"table": "papers", "semantic_search": "...", "limit": 10}, {"table": "books", "full_text_search": {...}, "limit": 5}]
             */
            queries: components["schemas"]["QueryRequest"][];
            summarizer: components["schemas"]["GeneratorConfig"];
            /**
             * @description Optional system prompt to guide the summarization
             * @example You are a helpful AI assistant. Summarize the following search results concisely.
             */
            system_prompt?: string;
            /**
             * @description Optional custom user prompt template for the LLM. If not provided, a default prompt is used.
             *     The prompt can reference the following variables:
             *     - {{documents}}: Array of retrieved documents with id and fields
             *     - {{semantic_search}}: The user's semantic search query (if provided)
             *     You can use Handlebars template syntax to customize the prompt, including loops and conditionals.
             *     To generate a comma-separated list of document IDs, use: {{#each documents}}{{this.id}}{{#unless @last}}, {{/unless}}{{/each}}
             * @example Based on these documents, provide a detailed analysis:
             *
             *     {{#each documents}}
             *     Doc {{this.id}}: {{this.fields}}
             *     {{/each}}
             *
             *     Valid IDs: {{#each documents}}{{this.id}}{{#unless @last}}, {{/unless}}{{/each}}
             */
            prompt?: string;
            /** @description Enable SSE streaming of results instead of JSON response */
            with_streaming?: boolean;
        };
        /** @description RAG result with individual query results and summary */
        RAGResult: {
            /** @description Results from each query. Check each result's status and error fields for failures. */
            query_results?: components["schemas"]["QueryResult"][];
            summary_result?: components["schemas"]["SummarizeResult"];
        };
        /**
         * @description Optional user context to customize the content guidance for each section of the answer agent response.
         *
         *     **What you can customize**: Style, tone, length, detail level, and focus of content for each section independently.
         *
         *     **What is fixed**: The response format is always markdown with consistent structure (## Reasoning, ## Answer, ## Follow-up Questions).
         *     Markdown formatting (headings, bullets, code blocks, etc.) is always applied and cannot be disabled.
         *
         *     **Architecture**: These contexts are passed as template variables to the prompt template. Defaults are set
         *     at the application layer, and users can override them via this API to customize content guidance.
         */
        UserContext: {
            /**
             * @description Custom content guidance for the reasoning section. Controls what information to include,
             *     the level of detail, and the focus of the reasoning process. Does not control markdown formatting.
             * @example Keep reasoning brief, 1-2 sentences maximum
             */
            reasoning_context?: string;
            /**
             * @description Custom content guidance for the answer section. Controls the tone, content depth, level of detail,
             *     and what information to emphasize. Does not control markdown formatting (which is always applied).
             * @example Provide a comprehensive answer with technical details and examples
             */
            answer_context?: string;
            /**
             * @description Custom content guidance for follow-up questions. Controls the quantity, focus area, tone,
             *     and style of follow-up questions. Does not control markdown formatting.
             * @example Generate 5 follow-up questions focused on technical specifications and pricing
             */
            followup_context?: string;
        };
        AnswerAgentRequest: {
            /**
             * @description User's natural language query to be classified and improved
             * @example What are the best gaming laptops under $2000?
             */
            query: string;
            summarizer: components["schemas"]["GeneratorConfig"];
            /**
             * @description Array of query requests to execute. The query text will be transformed for semantic search
             *     and populated into the semantic_search field of each query.
             * @example [
             *       {
             *         "table": "products",
             *         "indexes": [
             *           "embedding_idx"
             *         ],
             *         "limit": 10
             *       },
             *       {
             *         "table": "reviews",
             *         "indexes": [
             *           "embedding_idx"
             *         ],
             *         "limit": 5
             *       }
             *     ]
             */
            queries: components["schemas"]["QueryRequest"][];
            /**
             * @description Optional system prompt to guide classification and answer generation
             * @example You are a helpful shopping assistant.
             */
            system_prompt?: string;
            /**
             * @description Enable SSE streaming of results (classification, queries, results, answer) instead of JSON response
             * @default true
             */
            with_streaming: boolean;
            /**
             * @description Include the LLM's reasoning process as separate events before the answer
             * @default false
             */
            with_reasoning: boolean;
            /**
             * @description Include suggested follow-up questions as separate events after the answer
             * @default false
             */
            with_followup: boolean;
            user_context?: components["schemas"]["UserContext"];
        };
        /** @description Answer agent result with classification and generated answer with inline resource references */
        AnswerAgentResult: {
            /** @description Query classification and transformation result */
            classification_transformation?: components["schemas"]["ClassificationTransformationResult"];
            /** @description Results from each executed query */
            query_results?: components["schemas"]["QueryResult"][];
            /** @description LLM's reasoning process (if with_reasoning was enabled) */
            reasoning?: string;
            /** @description Generated answer (markdown format with inline resource references) */
            answer?: string;
            /** @description Suggested follow-up questions (if with_followup was enabled) */
            followup_questions?: string[];
        };
        QueryRequest: {
            /**
             * @description Name of the table to query. Optional for global queries.
             * @example wikipedia
             */
            table?: string;
            /**
             * @description Bleve query for full-text search. Supports all Bleve query types.
             *
             *     See bleve-query-openapi.yaml for complete type definitions.
             *
             *     Examples:
             *     - Simple: `{"query": "computer"}`
             *     - Field-specific: `{"query": "body:computer"}`
             *     - Boolean: `{"query": "artificial AND intelligence"}`
             *     - Range: `{"query": "year:>2020"}`
             *     - Phrase: `{"query": "\"exact phrase\""}`
             * @example {
             *       "query": "body:computer AND category:technology",
             *       "boost": 1
             *     }
             */
            full_text_search?: components["schemas"]["Query"] & {
                [key: string]: unknown;
            };
            /**
             * @description Natural language query for vector similarity search. Results are ranked by semantic similarity
             *     to the query and can be combined with full_text_search using Reciprocal Rank Fusion (RRF).
             *
             *     The semantic_search string is automatically embedded using the configured embedding model
             *     for the specified indexes.
             * @example artificial intelligence and machine learning applications
             */
            semantic_search?: string;
            /**
             * @description List of vector index names to use for semantic search. Required when using semantic_search.
             *     Multiple indexes can be specified, and their results will be merged using RRF.
             * @example [
             *       "title_body_nomic",
             *       "description_embedding"
             *     ]
             */
            indexes?: string[];
            /**
             * Format: byte
             * @description Filter results by key prefix. Only returns documents whose keys start with this string.
             *     Applied before scoring to improve performance.
             *
             *     Common use cases:
             *     - Multi-tenant filtering: `"tenant:acme:"`
             *     - User-specific data: `"user:123:"`
             *     - Document type filtering: `"article:"`
             */
            filter_prefix?: string;
            /**
             * @description Bleve query applied as an AND condition. Documents must match both the main query
             *     and this filter. Applied before scoring for better performance.
             *
             *     See bleve-query-openapi.yaml for complete type definitions.
             *
             *     Use for:
             *     - Status filtering: `"status:published"`
             *     - Date ranges: `"created_at:>2023-01-01"`
             *     - Category filtering: `"category:technology AND language:en"`
             * @example {
             *       "query": "category:technology AND year:>2020",
             *       "boost": 1
             *     }
             */
            filter_query?: components["schemas"]["Query"] & unknown;
            /**
             * @description Bleve query applied as a NOT condition. Documents matching this query are excluded
             *     from results. Applied before scoring.
             *
             *     See bleve-query-openapi.yaml for complete type definitions.
             *
             *     Use for:
             *     - Excluding drafts: `"status:draft"`
             *     - Removing deprecated content: `"deprecated:true"`
             *     - Filtering out archived items: `"status:archived"`
             * @example {
             *       "query": "category:deprecated OR status:archived",
             *       "boost": 1
             *     }
             */
            exclusion_query?: components["schemas"]["Query"] & unknown;
            /**
             * @description Faceting configuration for aggregating results by field values.
             *     Useful for building faceted navigation and filters.
             */
            facets?: {
                [key: string]: components["schemas"]["FacetOption"];
            };
            /**
             * @description Pre-computed embeddings to use for semantic searches instead of embedding the semantic_search string.
             *     The keys are the index names, and values are the embedding vectors.
             *
             *     Use when you've already generated embeddings on the client side to avoid redundant embedding calls.
             */
            embeddings?: {
                [key: string]: number[];
            };
            /**
             * @description List of fields to include in the results. If not specified, all fields are returned.
             *     Use to reduce response size and improve performance.
             * @example [
             *       "title",
             *       "url",
             *       "summary",
             *       "created_at"
             *     ]
             */
            fields?: string[];
            /**
             * @description Maximum number of results to return. For semantic_search, this is the topk parameter.
             *     Default varies by query type (typically 10).
             * @example 20
             */
            limit?: number;
            /**
             * @description Number of results to skip for pagination. Only available for full_text_search queries.
             *     Not supported for semantic_search due to vector index limitations.
             * @example 0
             */
            offset?: number;
            /**
             * @description Sort order for results. Map of field names to boolean (true = descending, false = ascending).
             *     Only applicable for full_text_search queries. Semantic searches are always sorted by similarity score.
             * @example {
             *       "created_at": true,
             *       "score": true
             *     }
             */
            order_by?: {
                [key: string]: boolean;
            };
            /**
             * Format: float
             * @description Maximum distance threshold for semantic similarity search. Results with distance
             *     greater than this value are excluded. Lower distances indicate higher similarity.
             *
             *     Useful for filtering out low-confidence matches.
             * @example 0.5
             */
            distance_under?: number;
            /**
             * Format: float
             * @description Minimum distance threshold for semantic similarity search. Results with distance
             *     less than this value are excluded.
             *
             *     Useful for excluding near-exact duplicates or finding dissimilar documents.
             * @example 0.1
             */
            distance_over?: number;
            merge_strategy?: components["schemas"]["MergeStrategy"];
            /**
             * @description If true, returns only the total count of matching documents without retrieving the actual documents.
             *     Useful for pagination and displaying result counts.
             * @example false
             */
            count?: boolean;
            reranker?: components["schemas"]["RerankerConfig"];
            analyses?: components["schemas"]["Analyses"];
            /**
             * @description Declarative graph queries to execute after full-text/vector searches.
             *     Results can reference search results using node selectors like $full_text_results.
             */
            graph_searches?: {
                [key: string]: components["schemas"]["GraphQuery"];
            };
            /**
             * @description Strategy for merging graph results with search results:
             *     - union: Include nodes from both search and graph results
             *     - intersection: Only include nodes appearing in both
             * @enum {string}
             */
            expand_strategy?: "union" | "intersection";
            /**
             * @description Optional Handlebars template string for rendering document content in RAG queries.
             *     Template has access to document fields via `{{this.fields.fieldName}}`.
             *
             *     Useful for customizing how documents are presented to LLMs in RAG pipelines.
             * @example Title: {{this.fields.title}}
             *     Body: {{this.fields.body}}
             *     URL: {{this.fields.url}}
             */
            document_renderer?: string;
            /**
             * @description Controls whether to search and return chunk documents in addition to original documents.
             *     When true (default): Searches both original documents and chunks, returns chunks in results.
             *     When false: Only searches original documents, excludes chunks from results.
             *
             *     Use false when you want to search only the original full documents without their chunked versions.
             * @example true
             */
            return_chunks?: boolean;
        };
        Analyses: {
            pca?: boolean;
            tsne?: boolean;
        };
        AnalysesResult: {
            pca?: number[];
            tsne?: number[];
        };
        /** @description A single query result hit */
        QueryHit: {
            /** @description ID of the record. */
            _id: string;
            /**
             * Format: float
             * @description Relevance score of the hit.
             */
            _score: number;
            /** @description Scores partitioned by index when using RRF search. */
            _index_scores?: {
                [key: string]: unknown;
            };
            _source?: {
                [key: string]: unknown;
            };
        };
        /** @description A list of query hits. */
        QueryHits: {
            /**
             * Format: uint64
             * @description Total number of hits available.
             */
            total?: number;
            hits?: components["schemas"]["QueryHit"][];
            /**
             * Format: float
             * @description Maximum score of the results.
             */
            max_score?: number;
        };
        /** @description Responses from multiple query operations. */
        QueryResponses: {
            responses?: components["schemas"]["QueryResult"][];
        };
        /** @description Result of a query operation as an array of results and a count. */
        QueryResult: {
            hits?: components["schemas"]["QueryHits"];
            facets?: {
                [key: string]: components["schemas"]["FacetResult"];
            };
            /** @description Analysis results like PCA and t-SNE per index embeddings. */
            analyses?: {
                [key: string]: components["schemas"]["AnalysesResult"];
            };
            /** @description Results from declarative graph queries. */
            graph_results?: {
                [key: string]: components["schemas"]["GraphQueryResult"];
            };
            /**
             * Format: int64
             * @description Duration of the query in milliseconds.
             */
            took: number;
            /**
             * Format: int32
             * @description HTTP status code of the query operation.
             */
            status: number;
            /** @description Error message if the query failed. */
            error?: string;
            /** @description Which table this result came from */
            table?: string;
        };
        /**
         * @description Status of a linear merge page operation:
         *     - "success": All records in batch processed successfully
         *     - "partial": Processing stopped at shard boundary, client should retry with next_cursor
         *     - "error": Fatal error occurred, no records processed successfully
         * @enum {string}
         */
        LinearMergePageStatus: "success" | "partial" | "error";
        /**
         * @description Linear merge operation for syncing sorted records from external sources.
         *     Use this to keep Antfly in sync with an external database or data source.
         *
         *     **How it works:**
         *     1. Send sorted records from your external source
         *     2. Server upserts records that exist in your batch
         *     3. Server deletes Antfly records in the key range that are absent from your batch
         *     4. If stopped at shard boundary, use next_cursor for next request
         *
         *     **WARNING:** Not safe for concurrent operations with overlapping key ranges.
         */
        LinearMergeRequest: {
            /**
             * @description Map of resource ID to resource object: {"resource_id_1": {...}, "resource_id_2": {...}}
             *
             *     Requirements:
             *     - Keys must be sorted lexicographically by your client
             *     - Server will process keys in sorted order
             *     - Use consistent key naming (e.g., all start with same prefix)
             *
             *     This format avoids duplicate IDs and matches Antfly's batch write interface.
             * @example {
             *       "product:001": {
             *         "name": "Laptop",
             *         "price": 999.99
             *       },
             *       "product:002": {
             *         "name": "Mouse",
             *         "price": 29.99
             *       },
             *       "product:003": {
             *         "name": "Keyboard",
             *         "price": 79.99
             *       }
             *     }
             */
            records: {
                [key: string]: unknown;
            };
            /**
             * @description ID of last record from previous merge request.
             *     - First request: Use empty string ""
             *     - Subsequent requests: Use next_cursor from previous response
             *     - Defines lower bound of key range to process
             *
             *     This enables pagination for large datasets.
             * @example product:003
             */
            last_merged_id?: string;
            /**
             * @description If true, returns what would be deleted without making changes.
             *
             *     Use cases:
             *     - Validate sync behavior before committing
             *     - Check which records will be removed
             *     - Test key range boundaries
             *
             *     Response includes deleted_ids array when dry_run=true.
             * @default false
             * @example false
             */
            dry_run: boolean;
            sync_level?: components["schemas"]["SyncLevel"];
        };
        FailedOperation: {
            id?: string;
            /** @enum {string} */
            operation?: "upsert" | "delete";
            error?: string;
        };
        /** @description Key range processed in this request */
        KeyRange: {
            from?: string;
            to?: string;
        };
        LinearMergeResult: {
            status: components["schemas"]["LinearMergePageStatus"];
            /** @description Records inserted or updated (0 if dry_run=true) */
            upserted: number;
            /** @description Records skipped because content hash matched (unchanged) */
            skipped: number;
            /** @description Records deleted or would be deleted (if dry_run=true) */
            deleted: number;
            /** @description IDs that were deleted (or would be deleted if dry_run=true). Only included if dry_run=true. */
            deleted_ids?: string[];
            failed?: components["schemas"]["FailedOperation"][];
            /** @description ID of last record in this batch (use for next request) */
            next_cursor: string;
            key_range?: components["schemas"]["KeyRange"];
            /** @description Total number of keys scanned from Antfly during range query */
            keys_scanned?: number;
            /** @description Additional information (e.g., "stopped at shard boundary", "dry run - no changes made") */
            message?: string;
            /** Format: int64 */
            took?: number;
        };
        /** @description A typed, weighted connection between documents */
        Edge: {
            /**
             * Format: byte
             * @description Base64-encoded source document key
             */
            source: string;
            /**
             * Format: byte
             * @description Base64-encoded target document key
             */
            target: string;
            /** @description Edge type (e.g., "cites", "similar_to", "authored_by") */
            type: string;
            /**
             * Format: double
             * @description Edge weight/confidence (0.0 to 1.0)
             */
            weight: number;
            /**
             * Format: date-time
             * @description When the edge was created
             */
            created_at?: string;
            /**
             * Format: date-time
             * @description When the edge was last updated
             */
            updated_at?: string;
            /** @description Optional edge metadata */
            metadata?: {
                [key: string]: unknown;
            };
        };
        /**
         * @description Direction of edges to query:
         *     - out: Outgoing edges from the node
         *     - in: Incoming edges to the node
         *     - both: Both outgoing and incoming edges
         * @default out
         * @enum {string}
         */
        EdgeDirection: "out" | "in" | "both";
        /** @description Rules for graph traversal */
        TraversalRules: {
            /** @description Filter edges by type (empty = all types) */
            edge_types?: string[];
            /**
             * Format: double
             * @description Minimum edge weight filter
             * @default 0
             */
            min_weight: number;
            /**
             * Format: double
             * @description Maximum edge weight filter
             * @default 1
             */
            max_weight: number;
            direction?: components["schemas"]["EdgeDirection"];
            /**
             * @description Maximum traversal depth (0 = unlimited)
             * @default 3
             */
            max_depth: number;
            /**
             * @description Maximum results to return (0 = unlimited)
             * @default 100
             */
            max_results: number;
            /**
             * @description Include path information in results
             * @default false
             */
            include_paths: boolean;
            /**
             * @description Visit each node only once
             * @default true
             */
            deduplicate_nodes: boolean;
        };
        /** @description A single result from graph traversal */
        TraversalResult: {
            /**
             * Format: byte
             * @description Base64-encoded document key
             */
            key: string;
            /** @description Document data (if loaded) */
            document?: {
                [key: string]: unknown;
            };
            /** @description Distance from start node (0 = start node) */
            depth: number;
            /** @description Sequence of keys from start to this node (if include_paths=true) */
            path?: string[];
            /** @description Sequence of edges from start to this node (if include_paths=true) */
            path_edges?: components["schemas"]["Edge"][];
            /**
             * Format: double
             * @description Product of edge weights along the path
             */
            total_weight?: number;
        };
        EdgesResponse: {
            edges?: components["schemas"]["Edge"][];
            /** @description Total number of edges returned */
            count?: number;
        };
        TraverseResponse: {
            results?: components["schemas"]["TraversalResult"][];
            /** @description Total number of results */
            count?: number;
        };
        /**
         * @description Algorithm for path finding:
         *     - min_hops: Shortest path by hop count (breadth-first search, ignores weights)
         *     - max_weight: Path with maximum product of edge weights (strongest connection chain)
         *     - min_weight: Path with minimum sum of edge weights (lowest cost route)
         * @default min_hops
         * @enum {string}
         */
        PathFindWeightMode: "min_hops" | "max_weight" | "min_weight";
        PathFindRequest: {
            /** @description Source node key (base64-encoded) */
            source: string;
            /** @description Target node key (base64-encoded) */
            target: string;
            /** @description Filter by specific edge types */
            edge_types?: string[];
            /** @default 10 */
            max_depth: number;
            weight_mode?: components["schemas"]["PathFindWeightMode"];
            /** @default 1 */
            k: number;
            /** Format: double */
            min_weight?: number;
            /** Format: double */
            max_weight?: number;
            direction?: components["schemas"]["EdgeDirection"];
        };
        PathFindResult: {
            paths?: components["schemas"]["Path"][];
            source?: string;
            target?: string;
            weight_mode?: components["schemas"]["PathFindWeightMode"];
            paths_found?: number;
            /** Format: double */
            search_time_ms?: number;
        };
        Path: {
            /** @description Ordered list of node keys (base64-encoded) */
            nodes?: string[];
            edges?: components["schemas"]["PathEdge"][];
            /** Format: double */
            total_weight?: number;
            length?: number;
        };
        PathEdge: {
            source?: string;
            target?: string;
            type?: string;
            /** Format: double */
            weight?: number;
            metadata?: {
                [key: string]: unknown;
            };
        };
        /**
         * Format: double
         * @description A floating-point number used to decrease or increase the relevance scores of a query.
         * @default 1
         */
        Boost: number | null;
        TermQuery: {
            term: string;
            field?: string;
            boost?: components["schemas"]["Boost"];
        };
        /** @description The fuzziness of the query. Can be an integer or "auto". */
        Fuzziness: number | "auto";
        MatchQuery: {
            match: string;
            field?: string;
            analyzer?: string;
            boost?: components["schemas"]["Boost"];
            /** Format: int32 */
            prefix_length?: number;
            fuzziness?: components["schemas"]["Fuzziness"];
            /** @enum {string} */
            operator?: "or" | "and";
        };
        MatchPhraseQuery: {
            match_phrase: string;
            field?: string;
            analyzer?: string;
            boost?: components["schemas"]["Boost"];
            fuzziness?: components["schemas"]["Fuzziness"];
        };
        PhraseQuery: {
            terms: string[];
            field?: string;
            boost?: components["schemas"]["Boost"];
            fuzziness?: components["schemas"]["Fuzziness"];
        };
        MultiPhraseQuery: {
            terms: string[][];
            field?: string;
            boost?: components["schemas"]["Boost"];
            fuzziness?: components["schemas"]["Fuzziness"];
        };
        FuzzyQuery: {
            term: string;
            /** Format: int32 */
            prefix_length?: number;
            fuzziness?: components["schemas"]["Fuzziness"];
            field?: string;
            boost?: components["schemas"]["Boost"];
        };
        PrefixQuery: {
            prefix: string;
            field?: string;
            boost?: components["schemas"]["Boost"];
        };
        RegexpQuery: {
            regexp: string;
            field?: string;
            boost?: components["schemas"]["Boost"];
        };
        WildcardQuery: {
            wildcard: string;
            field?: string;
            boost?: components["schemas"]["Boost"];
        };
        QueryStringQuery: {
            query: string;
            boost?: components["schemas"]["Boost"];
        };
        NumericRangeQuery: {
            /** Format: double */
            min?: number | null;
            /** Format: double */
            max?: number | null;
            inclusive_min?: boolean | null;
            inclusive_max?: boolean | null;
            field?: string;
            boost?: components["schemas"]["Boost"];
        };
        TermRangeQuery: {
            min?: string | null;
            max?: string | null;
            inclusive_min?: boolean | null;
            inclusive_max?: boolean | null;
            field?: string;
            boost?: components["schemas"]["Boost"];
        };
        DateRangeStringQuery: {
            /** Format: date-time */
            start?: string;
            /** Format: date-time */
            end?: string;
            inclusive_start?: boolean | null;
            inclusive_end?: boolean | null;
            field?: string;
            boost?: components["schemas"]["Boost"];
            datetime_parser?: string;
        };
        Query: components["schemas"]["TermQuery"] | components["schemas"]["MatchQuery"] | components["schemas"]["MatchPhraseQuery"] | components["schemas"]["PhraseQuery"] | components["schemas"]["MultiPhraseQuery"] | components["schemas"]["FuzzyQuery"] | components["schemas"]["PrefixQuery"] | components["schemas"]["RegexpQuery"] | components["schemas"]["WildcardQuery"] | components["schemas"]["QueryStringQuery"] | components["schemas"]["NumericRangeQuery"] | components["schemas"]["TermRangeQuery"] | components["schemas"]["DateRangeStringQuery"] | components["schemas"]["BooleanQuery"] | components["schemas"]["ConjunctionQuery"] | components["schemas"]["DisjunctionQuery"] | components["schemas"]["MatchAllQuery"] | components["schemas"]["MatchNoneQuery"] | components["schemas"]["DocIdQuery"] | components["schemas"]["BoolFieldQuery"] | components["schemas"]["IPRangeQuery"] | components["schemas"]["GeoBoundingBoxQuery"] | components["schemas"]["GeoDistanceQuery"] | components["schemas"]["GeoBoundingPolygonQuery"] | components["schemas"]["GeoShapeQuery"];
        ConjunctionQuery: {
            conjuncts: components["schemas"]["Query"][];
            boost?: components["schemas"]["Boost"];
        };
        DisjunctionQuery: {
            disjuncts: components["schemas"]["Query"][];
            boost?: components["schemas"]["Boost"];
            /** Format: double */
            min?: number;
        };
        BooleanQuery: {
            must?: components["schemas"]["ConjunctionQuery"];
            should?: components["schemas"]["DisjunctionQuery"];
            must_not?: components["schemas"]["DisjunctionQuery"];
            filter?: components["schemas"]["Query"];
            boost?: components["schemas"]["Boost"];
        };
        MatchAllQuery: {
            match_all: Record<string, never>;
            boost?: components["schemas"]["Boost"];
        };
        MatchNoneQuery: {
            match_none: Record<string, never>;
            boost?: components["schemas"]["Boost"];
        };
        DocIdQuery: {
            ids: string[];
            boost?: components["schemas"]["Boost"];
        };
        BoolFieldQuery: {
            bool: boolean;
            field?: string;
            boost?: components["schemas"]["Boost"];
        };
        IPRangeQuery: {
            cidr: string;
            field?: string;
            boost?: components["schemas"]["Boost"];
        };
        GeoBoundingBoxQuery: {
            /** @description [lon, lat] */
            top_left: number[];
            /** @description [lon, lat] */
            bottom_right: number[];
            field?: string;
            boost?: components["schemas"]["Boost"];
        };
        GeoDistanceQuery: {
            /** @description [lon, lat] */
            location: number[];
            /** @example 10km */
            distance: string;
            field?: string;
            boost?: components["schemas"]["Boost"];
        };
        GeoPoint: {
            /** Format: double */
            lon?: number;
            /** Format: double */
            lat?: number;
        };
        GeoBoundingPolygonQuery: {
            polygon_points: components["schemas"]["GeoPoint"][];
            field?: string;
            boost?: components["schemas"]["Boost"];
        };
        /** @description A GeoJSON shape object. This is a simplified representation. */
        GeoShape: {
            type: string;
            coordinates: unknown[];
        };
        GeoShapeGeometry: {
            shape: components["schemas"]["GeoShape"];
            /** @enum {string} */
            relation: "intersects" | "contains" | "within";
        };
        GeoShapeQuery: {
            geometry: components["schemas"]["GeoShapeGeometry"];
            field?: string;
            boost?: components["schemas"]["Boost"];
        };
        /**
         * @description Merge strategy for combining results from the semantic_search and full_text_search.
         *     rrf: Reciprocal Rank Fusion - combines scores using reciprocal rank formula
         *     rsf: Relative Score Fusion - normalizes scores by min/max within a window and combines weighted scores
         *     failover: Use full_text_search if embedding generation fails
         * @default rrf
         * @enum {string}
         */
        MergeStrategy: "rrf" | "rsf" | "failover";
        /**
         * @description The reranking provider to use.
         * @enum {string}
         */
        RerankerProvider: "ollama" | "termite";
        /** @description Configuration for the Ollama reranking provider. */
        OllamaRerankerConfig: {
            /** @description The name of the Ollama model to use for reranking. */
            model: string;
            /**
             * Format: uri
             * @description The URL of the Ollama API endpoint.
             */
            url?: string;
        };
        /** @description Configuration for the Termite reranking provider. */
        TermiteRerankerConfig: {
            /** @description The name of the reranking model (e.g., cross-encoder model name). */
            model: string;
            /**
             * Format: uri
             * @description The URL of the Termite API endpoint.
             */
            url?: string;
        };
        /**
         * @description A unified configuration for a reranking provider.
         * @example {
         *       "provider": "ollama",
         *       "model": "dengcao/Qwen3-Reranker-0.6B:F16",
         *       "field": "content"
         *     }
         */
        RerankerConfig: {
            provider: components["schemas"]["RerankerProvider"];
            /** @description Field name to extract from documents for reranking. */
            field?: string;
            /** @description Handlebars template to render document text for reranking. */
            template?: string;
        } & (components["schemas"]["OllamaRerankerConfig"] | components["schemas"]["TermiteRerankerConfig"]);
        /**
         * @description Type of graph query to execute
         * @enum {string}
         */
        GraphQueryType: "traverse" | "neighbors" | "shortest_path" | "k_shortest_paths";
        /** @description Defines how to select start/target nodes for graph queries */
        GraphNodeSelector: {
            /** @description Explicit list of node keys */
            keys?: string[];
            /**
             * @description Reference to search results to use as nodes:
             *     - "$full_text_results" - use full-text search results
             *     - "$aknn_results.index_name" - use vector search results from specific index
             */
            result_ref?: string;
            /** @description Maximum number of nodes to select from the referenced results */
            limit?: number;
        };
        /**
         * @description Path weighting algorithm for pathfinding:
         *     - min_hops: Minimize number of edges
         *     - min_weight: Minimize sum of edge weights
         *     - max_weight: Maximize product of edge weights
         * @enum {string}
         */
        PathWeightMode: "min_hops" | "min_weight" | "max_weight";
        /** @description Parameters for graph traversal and pathfinding */
        GraphQueryParams: {
            /** @description Filter by edge types */
            edge_types?: string[];
            direction?: components["schemas"]["EdgeDirection"];
            /** @description Maximum traversal depth */
            max_depth?: number;
            /**
             * Format: double
             * @description Minimum edge weight
             */
            min_weight?: number;
            /**
             * Format: double
             * @description Maximum edge weight
             */
            max_weight?: number;
            /** @description Maximum number of results (traversal) */
            max_results?: number;
            /** @description Remove duplicate nodes (traversal) */
            deduplicate_nodes?: boolean;
            /** @description Include path information (traversal) */
            include_paths?: boolean;
            weight_mode?: components["schemas"]["PathWeightMode"];
            /** @description Number of paths to find (k-shortest-paths) */
            k?: number;
            /** @description Graph algorithm to run (e.g., 'pagerank', 'betweenness') */
            algorithm?: string;
            /** @description Parameters for the graph algorithm */
            algorithm_params?: {
                [key: string]: unknown;
            };
        };
        /** @description Declarative graph query to execute after full-text/vector searches */
        GraphQuery: {
            type: components["schemas"]["GraphQueryType"];
            /** @description Graph index name (must be graph_v0 type) */
            index_name: string;
            /** @description Starting node(s) for the query */
            start_nodes: components["schemas"]["GraphNodeSelector"];
            /** @description Target nodes (for pathfinding only) */
            target_nodes?: components["schemas"]["GraphNodeSelector"];
            /** @description Traversal/pathfinding parameters */
            params: components["schemas"]["GraphQueryParams"];
            /** @description Fetch full documents for graph results */
            include_documents?: boolean;
            /** @description Include edge details for each node */
            include_edges?: boolean;
            /** @description Which fields to return from documents */
            fields?: string[];
        };
        /** @description A node in graph query results */
        GraphResultNode: {
            /** @description Document key */
            key: string;
            /** @description Distance from start node */
            depth?: number;
            /**
             * Format: double
             * @description Weighted distance
             */
            distance?: number;
            /** @description Full document (if include_documents=true) */
            document?: {
                [key: string]: unknown;
            };
            /** @description Keys in path from start to this node */
            path?: string[];
            /** @description Edges in path from start to this node */
            path_edges?: components["schemas"]["PathEdge"][];
            /** @description Connected edges (when include_edges=true) */
            edges?: components["schemas"]["Edge"][];
        };
        /** @description Results of a graph query */
        GraphQueryResult: {
            type: components["schemas"]["GraphQueryType"];
            /** @description Result nodes */
            nodes?: components["schemas"]["GraphResultNode"][];
            /** @description Result paths (for pathfinding queries) */
            paths?: components["schemas"]["Path"][];
            /** @description Total number of results */
            total: number;
            /**
             * Format: int64
             * @description Query execution time
             */
            took?: number;
        };
        /** @description Configuration for the Google generative AI provider (Gemini). Defaults to gemini-2.5-flash if no model is specified. */
        GoogleGeneratorConfig: {
            /** @description The Google Cloud project ID. */
            project_id?: string;
            /** @description The Google Cloud location (e.g., 'us-central1'). */
            location?: string;
            /**
             * @description The name of the generative model to use (e.g., 'gemini-2.5-flash', 'gemini-1.5-pro').
             * @default gemini-2.5-flash
             */
            model: string;
            /**
             * Format: float
             * @description Controls randomness in generation (0.0-2.0).
             */
            temperature?: number;
            /** @description Maximum number of tokens to generate. */
            max_tokens?: number;
            /**
             * Format: float
             * @description Nucleus sampling parameter.
             */
            top_p?: number;
            /** @description Top-k sampling parameter. */
            top_k?: number;
            /** @description The Google API key. */
            api_key?: string;
            /**
             * Format: uri
             * @description The URL of the Google API endpoint.
             */
            url?: string;
        };
        /**
         * @description Configuration for Google Cloud Vertex AI generative models (enterprise-grade).
         *
         *     Uses Application Default Credentials (ADC) for authentication by default.
         *     Suitable for production deployments on Google Cloud Platform.
         *
         *     **Authentication Priority:**
         *     1. credentials_path (path to service account key file)
         *     2. GOOGLE_APPLICATION_CREDENTIALS environment variable
         *     3. Application Default Credentials (ADC) - RECOMMENDED
         *        - In GCP: automatic (Cloud Run, GKE, Compute Engine)
         *        - Local dev: `gcloud auth application-default login`
         *
         *     **Note:** credentials_json is not supported by the genkit VertexAI plugin.
         *     Use credentials_path or ADC instead.
         *
         *     **Required IAM Permission:** `roles/aiplatform.user`
         *
         *     **Supported Models:**
         *     - gemini-2.5-flash (default, fast and efficient)
         *     - gemini-1.5-pro (balanced performance)
         *     - gemini-1.5-flash (cost-effective)
         *     - gemini-2.0-pro (advanced reasoning)
         *
         *     Defaults to gemini-2.5-flash if no model is specified.
         * @example {
         *       "provider": "vertex",
         *       "model": "gemini-2.5-flash",
         *       "project_id": "my-gcp-project",
         *       "location": "us-central1",
         *       "temperature": 0.7,
         *       "max_tokens": 4096
         *     }
         */
        VertexGeneratorConfig: {
            /**
             * @description The name of the Vertex AI model to use.
             * @default gemini-2.5-flash
             * @example gemini-2.5-flash
             */
            model: string;
            /** @description Google Cloud project ID. Can also be set via GOOGLE_CLOUD_PROJECT environment variable. */
            project_id?: string;
            /**
             * @description Google Cloud region for Vertex AI API (e.g., 'us-central1', 'europe-west1'). Can also be set via GOOGLE_CLOUD_LOCATION. Defaults to 'us-central1'.
             * @default us-central1
             */
            location: string;
            /** @description Path to service account JSON key file. Sets GOOGLE_APPLICATION_CREDENTIALS environment variable. Alternative to ADC for non-GCP environments. */
            credentials_path?: string;
            /**
             * Format: float
             * @description Controls randomness in generation (0.0-2.0). Higher values make output more random.
             */
            temperature?: number;
            /** @description Maximum number of tokens to generate in the response. */
            max_tokens?: number;
            /**
             * Format: float
             * @description Nucleus sampling parameter (0.0-1.0). Alternative to temperature.
             */
            top_p?: number;
            /** @description Top-k sampling parameter. Only sample from the top K options for each subsequent token. */
            top_k?: number;
        };
        /** @description Configuration for the Ollama generative AI provider. */
        OllamaGeneratorConfig: {
            /** @description The name of the Ollama model to use (e.g., 'llama3.2', 'llava'). */
            model: string;
            /**
             * Format: uri
             * @description The URL of the Ollama API endpoint.
             */
            url?: string;
            /**
             * Format: float
             * @description Controls randomness in generation (0.0-2.0).
             */
            temperature?: number;
            /** @description Maximum number of tokens to generate. */
            max_tokens?: number;
            /**
             * Format: float
             * @description Nucleus sampling parameter.
             */
            top_p?: number;
            /** @description Top-k sampling parameter. */
            top_k?: number;
        };
        /** @description Configuration for the OpenAI generative AI provider. */
        OpenAIGeneratorConfig: {
            /** @description The name of the OpenAI model to use (e.g., 'gpt-4o', 'gpt-4-turbo'). */
            model: string;
            /**
             * Format: uri
             * @description The URL of the OpenAI API endpoint.
             */
            url?: string;
            /** @description The OpenAI API key. */
            api_key?: string;
            /**
             * Format: float
             * @description Controls randomness in generation (0.0-2.0).
             */
            temperature?: number;
            /** @description Maximum number of tokens to generate. */
            max_tokens?: number;
            /**
             * Format: float
             * @description Nucleus sampling parameter.
             */
            top_p?: number;
            /**
             * Format: float
             * @description Penalty for token frequency (-2.0 to 2.0).
             */
            frequency_penalty?: number;
            /**
             * Format: float
             * @description Penalty for token presence (-2.0 to 2.0).
             */
            presence_penalty?: number;
        };
        /** @description Configuration for the AWS Bedrock generative AI provider. */
        BedrockGeneratorConfig: {
            /**
             * @description The name of the Bedrock model to use.
             * @example anthropic.claude-3-5-sonnet-20241022-v2:0
             */
            model: string;
            /** @description The AWS region for the Bedrock service. */
            region?: string;
            /**
             * Format: float
             * @description Controls randomness in generation (0.0-1.0).
             */
            temperature?: number;
            /** @description Maximum number of tokens to generate. */
            max_tokens?: number;
            /**
             * Format: float
             * @description Nucleus sampling parameter.
             */
            top_p?: number;
            /** @description Top-k sampling parameter. */
            top_k?: number;
        };
        /**
         * @description Configuration for the Anthropic generative AI provider (Claude models).
         *     Uses the firebase/genkit compat_oai/anthropic plugin with OpenAI-compatible API.
         *
         *     Defaults to claude-3-7-sonnet-20250219 if no model is specified.
         *
         *     API key can be provided via the 'api_key' field or the ANTHROPIC_API_KEY environment variable.
         *
         *     Supported models:
         *     - claude-3-7-sonnet-20250219 (latest, most capable)
         *     - claude-3-5-haiku-20241022 (fast and efficient)
         *     - claude-3-5-sonnet-20240620 (balanced performance)
         *     - claude-3-opus-20240229 (highly capable)
         *     - claude-3-haiku-20240307 (fastest)
         * @example {
         *       "provider": "anthropic",
         *       "model": "claude-3-7-sonnet-20250219",
         *       "temperature": 0.7,
         *       "max_tokens": 4096
         *     }
         */
        AnthropicGeneratorConfig: {
            /**
             * @description The full model ID of the Anthropic model to use (e.g., 'claude-3-7-sonnet-20250219', 'claude-3-5-haiku-20241022').
             * @default claude-3-7-sonnet-20250219
             * @example claude-3-7-sonnet-20250219
             */
            model: string;
            /** @description The Anthropic API key. If not provided, falls back to ANTHROPIC_API_KEY environment variable. */
            api_key?: string;
            /**
             * Format: uri
             * @description The URL of the Anthropic API endpoint (optional, uses default if not specified).
             */
            url?: string;
            /**
             * Format: float
             * @description Controls randomness in generation (0.0-1.0). Higher values make output more random.
             */
            temperature?: number;
            /** @description Maximum number of tokens to generate in the response. */
            max_tokens?: number;
            /**
             * Format: float
             * @description Nucleus sampling parameter (0.0-1.0). Alternative to temperature.
             */
            top_p?: number;
            /** @description Top-k sampling parameter. Only sample from the top K options for each subsequent token. */
            top_k?: number;
        };
        /**
         * @description The generative AI provider to use.
         * @enum {string}
         */
        GeneratorProvider: "gemini" | "vertex" | "ollama" | "openai" | "bedrock" | "anthropic" | "mock";
        /**
         * @description A unified configuration for a generative AI provider.
         * @example {
         *       "provider": "openai",
         *       "model": "gpt-4o",
         *       "temperature": 0.7,
         *       "max_tokens": 2048
         *     }
         */
        GeneratorConfig: (components["schemas"]["GoogleGeneratorConfig"] | components["schemas"]["VertexGeneratorConfig"] | components["schemas"]["OllamaGeneratorConfig"] | components["schemas"]["OpenAIGeneratorConfig"] | components["schemas"]["BedrockGeneratorConfig"] | components["schemas"]["AnthropicGeneratorConfig"]) & {
            provider: components["schemas"]["GeneratorProvider"];
        };
        /** @description Result of a summarization operation. The summary is formatted as markdown with inline resource references using [resource_id <id>] or [resource_id <id1>, <id2>] format. */
        SummarizeResult: {
            /** @description The generated summary text in markdown format with inline resource references like [resource_id res1] or [resource_id res1, res2] */
            summary: string;
        };
        /**
         * @description Classification of query type: question (specific factual query) or search (exploratory query)
         * @enum {string}
         */
        RouteType: "question" | "search";
        /** @description Query classification and transformation result combining all query enhancements */
        ClassificationTransformationResult: {
            route_type: components["schemas"]["RouteType"];
            /** @description Clarified query with added context for answer generation (human-readable) */
            improved_query: string;
            /** @description Optimized query for vector/semantic search (concept extraction with synonyms) */
            semantic_query: string;
            /**
             * Format: float
             * @description Classification confidence (0.0 to 1.0)
             */
            confidence: number;
        };
        BleveIndexV2Config: {
            /** @description Whether to use memory-only storage */
            mem_only?: boolean;
        };
        /** @description Configuration for the Google embedding provider. */
        GoogleEmbedderConfig: {
            /** @description The Google Cloud project ID. */
            project_id?: string;
            /** @description The Google Cloud location (e.g., 'us-central1'). */
            location?: string;
            /**
             * @description The name of the embedding model to use (e.g., 'text-embedding-004').
             * @default text-embedding-004
             */
            model: string;
            /**
             * @description The dimension of the embedding.
             * @default 1024
             */
            dimension: number;
            /** @description The Google API key. */
            api_key?: string;
            /**
             * Format: uri
             * @description The URL of the Google API endpoint.
             */
            url?: string;
        };
        /**
         * @description Configuration for Google Cloud Vertex AI embedding models (enterprise-grade).
         *
         *     Uses Application Default Credentials (ADC) for authentication by default.
         *     Suitable for production deployments on Google Cloud Platform.
         *
         *     **Authentication Priority:**
         *     1. credentials_path (path to service account key file)
         *     2. GOOGLE_APPLICATION_CREDENTIALS environment variable
         *     3. Application Default Credentials (ADC) - RECOMMENDED
         *        - In GCP: automatic (Cloud Run, GKE, Compute Engine)
         *        - Local dev: `gcloud auth application-default login`
         *
         *     **Required IAM Permission:** `roles/aiplatform.user`
         *
         *     **Supported Models:**
         *     - text-embedding-004 (latest, 768 dimensions)
         *     - textembedding-gecko@003, @002, @001 (legacy)
         *     - textembedding-gecko-multilingual@001 (multilingual support)
         *     - text-multilingual-embedding-002 (multilingual, 768 dimensions)
         *     - multimodalembedding (images, audio, video - 128/256/512/1408 dimensions)
         * @example {
         *       "provider": "vertex",
         *       "model": "text-embedding-004",
         *       "project_id": "my-gcp-project",
         *       "location": "us-central1",
         *       "dimension": 768
         *     }
         */
        VertexEmbedderConfig: {
            /**
             * @description The name of the Vertex AI embedding model to use.
             * @example text-embedding-004
             */
            model: string;
            /** @description Google Cloud project ID. Can also be set via GOOGLE_CLOUD_PROJECT environment variable. */
            project_id?: string;
            /**
             * @description Google Cloud region for Vertex AI API (e.g., 'us-central1', 'europe-west1'). Can also be set via GOOGLE_CLOUD_LOCATION. Defaults to 'us-central1'.
             * @default us-central1
             */
            location: string;
            /** @description Path to service account JSON key file. Alternative to ADC for non-GCP environments. */
            credentials_path?: string;
            /**
             * @description The dimension of the embedding vector. Model-specific (e.g., 768 for text-embedding-004, 128-1408 for multimodalembedding).
             * @default 768
             */
            dimension: number;
        };
        /** @description Configuration for the Ollama embedding provider. */
        OllamaEmbedderConfig: {
            /** @description The name of the Ollama model to use. */
            model: string;
            /**
             * Format: uri
             * @description The URL of the Ollama API endpoint.
             */
            url?: string;
        };
        /** @description Configuration for the OpenAI embedding provider. */
        OpenAIEmbedderConfig: {
            /** @description The name of the OpenAI model to use. */
            model: string;
            /**
             * Format: uri
             * @description The URL of the OpenAI API endpoint.
             */
            url?: string;
            /** @description The OpenAI API key. */
            api_key?: string;
        };
        /** @description Configuration for the Bedrock embedding provider. */
        BedrockEmbedderConfig: {
            /**
             * @description The name of the Bedrock model to use.
             * @example amazon.titan-embed-text-v1
             */
            model: string;
            /** @description The AWS region for the Bedrock service. */
            region?: string;
            /** @description Whether to strip new lines from the input text. */
            strip_new_lines?: boolean;
            /** @description The batch size for embedding requests. */
            batch_size?: number;
        };
        /**
         * @description The embedding provider to use.
         * @enum {string}
         */
        EmbedderProvider: "gemini" | "vertex" | "ollama" | "openai" | "bedrock" | "mock";
        /**
         * @description A unified configuration for an embedding provider.
         * @example {
         *       "provider": "openai",
         *       "model": "text-embedding-004"
         *     }
         */
        EmbedderConfig: (components["schemas"]["GoogleEmbedderConfig"] | components["schemas"]["VertexEmbedderConfig"] | components["schemas"]["OllamaEmbedderConfig"] | components["schemas"]["OpenAIEmbedderConfig"] | components["schemas"]["BedrockEmbedderConfig"]) & {
            provider: components["schemas"]["EmbedderProvider"];
        };
        /**
         * @description Document chunking strategy.
         *     - hugot: ONNX-accelerated chunking using sentence boundary detection
         *     - fixed: Simple fixed-size chunking by token count
         * @enum {string}
         */
        ChunkingStrategy: "hugot" | "fixed";
        /**
         * @description Configuration for the Termite chunking provider.
         *
         *     Termite is a centralized HTTP service that provides chunking with multi-tier caching.
         *     It supports multiple chunking strategies similar to how generators support different models.
         *
         *     **Chunking Strategies:**
         *     - hugot: ONNX-accelerated chunking using sentence boundary detection
         *     - fixed: Simple fixed-size chunking by token count (default, no ONNX required)
         *
         *     **Caching:**
         *     - L1: Memory cache with 2-minute TTL
         *     - L2: Persistent Pebble database
         *     - Singleflight deduplication for concurrent identical requests
         * @example {
         *       "provider": "termite",
         *       "api_url": "http://localhost:8080",
         *       "strategy": "fixed",
         *       "target_tokens": 500,
         *       "overlap_tokens": 50,
         *       "separator": "\n\n",
         *       "max_chunks": 50,
         *       "full_text": {}
         *     }
         */
        TermiteChunkerConfig: {
            /**
             * Format: uri
             * @description The URL of the Termite API endpoint (e.g., 'http://localhost:8080'). Can also be set via ANTFLY_TERMITE_URL environment variable.
             * @example http://localhost:8080
             */
            api_url?: string;
            /**
             * @description The chunking strategy to use. Like 'model' in generators - determines the chunking algorithm.
             * @default fixed
             */
            strategy: components["schemas"]["ChunkingStrategy"];
            /**
             * @description Target number of tokens per chunk. Chunker will aim for chunks around this size.
             * @default 500
             */
            target_tokens: number;
            /**
             * @description Number of tokens to overlap between consecutive chunks. Helps maintain context across chunk boundaries.
             * @default 50
             */
            overlap_tokens: number;
            /**
             * @description Separator string for splitting (e.g., '\n\n' for paragraphs). Only used with fixed strategy.
             * @default
             */
            separator: string;
            /**
             * @description Maximum number of chunks to generate per document. Prevents excessive chunking of very large documents.
             * @default 50
             */
            max_chunks: number;
            /**
             * Format: float
             * @description Minimum confidence threshold for separator detection. Only used with hugot strategy.
             * @default 0.5
             */
            threshold: number;
            /**
             * @description Configuration for full-text indexing of chunks in Bleve.
             *     When present (even if empty), chunks will be stored with :cft: suffix and indexed in Bleve's _chunks field.
             *     When absent, chunks use :c: suffix and are only used for vector embeddings.
             *     This object is reserved for future options like boosting, field mapping, etc.
             * @example {}
             */
            full_text?: {
                [key: string]: unknown;
            };
        };
        /**
         * @description Configuration for the local Antfly chunking provider.
         *
         *     This provider runs chunking directly within the storage node process,
         *     without requiring an external Termite service. It uses simple fixed-size
         *     tokenizer-based chunking with no caching overhead.
         *
         *     **Use this when:**
         *     - Running single-node deployments (swarm mode)
         *     - You don't need embedding/chunk caching across nodes
         *     - You want minimal setup complexity
         *
         *     **Use Termite instead when:**
         *     - Running multi-node clusters where caching reduces costs
         *     - You need ONNX-accelerated chunking (hugot strategy)
         *     - You want persistent chunk/embedding caches
         * @example {
         *       "provider": "antfly",
         *       "target_tokens": 500,
         *       "overlap_tokens": 50,
         *       "separator": "\n\n",
         *       "max_chunks": 50
         *     }
         */
        AntflyChunkerConfig: {
            /**
             * @description Target number of tokens per chunk. Chunker will aim for chunks around this size.
             * @default 500
             */
            target_tokens: number;
            /**
             * @description Number of tokens to overlap between consecutive chunks. Helps maintain context across chunk boundaries.
             * @default 50
             */
            overlap_tokens: number;
            /**
             * @description Separator string for splitting (e.g., '\n\n' for paragraphs).
             * @default
             */
            separator: string;
            /**
             * @description Maximum number of chunks to generate per document. Prevents excessive chunking of very large documents.
             * @default 50
             */
            max_chunks: number;
            /**
             * @description Configuration for full-text indexing of chunks in Bleve.
             *     When present (even if empty), chunks will be stored with :cft: suffix and indexed in Bleve's _chunks field.
             *     When absent, chunks use :c: suffix and are only used for vector embeddings.
             *     This object is reserved for future options like boosting, field mapping, etc.
             * @example {}
             */
            full_text?: {
                [key: string]: unknown;
            };
        };
        /**
         * @description The chunking provider to use.
         * @enum {string}
         */
        ChunkerProvider: "mock" | "termite" | "antfly";
        /**
         * @description A unified configuration for a chunking provider.
         * @example {
         *       "provider": "termite",
         *       "strategy": "fixed",
         *       "target_tokens": 500,
         *       "overlap_tokens": 50
         *     }
         */
        ChunkerConfig: (components["schemas"]["TermiteChunkerConfig"] | components["schemas"]["AntflyChunkerConfig"]) & {
            provider: components["schemas"]["ChunkerProvider"];
        };
        EmbeddingIndexConfig: {
            /** @description Vector dimension */
            dimension: number;
            /** @description Field to extract embeddings from */
            field?: string;
            /**
             * @description Handlebars template for generating prompts. See https://handlebarsjs.com/guide/ for more information.
             * @example Hello, {{#if (eq Name "John")}}Johnathan{{else}}{{Name}}{{/if}}! You are {{Age}} years old.
             */
            template?: string;
            /** @description Whether to use in-memory only storage */
            mem_only?: boolean;
            /** @description Configuration for the embeddings plugin */
            embedder?: components["schemas"]["EmbedderConfig"];
            /** @description Configuration for the summarizer plugin */
            summarizer?: components["schemas"]["GeneratorConfig"];
            /** @description Configuration for the chunking plugin. When specified, documents are automatically chunked at write time before indexing. */
            chunker?: components["schemas"]["ChunkerConfig"];
        };
        /** @description Configuration for a specific edge type */
        EdgeTypeConfig: {
            /** @description Edge type name (e.g., 'cites', 'similar_to') */
            name: string;
            /**
             * Format: double
             * @description Maximum allowed edge weight
             * @default 1
             */
            max_weight: number;
            /**
             * Format: double
             * @description Minimum allowed edge weight
             * @default 0
             */
            min_weight: number;
            /**
             * @description Whether to allow edges from a node to itself
             * @default true
             */
            allow_self_loops: boolean;
            /** @description Required metadata fields for this edge type */
            required_metadata?: string[];
        };
        /** @description Configuration for graph_v0 index type */
        GraphIndexV0Config: {
            /** @description List of edge types with their configurations */
            edge_types?: components["schemas"]["EdgeTypeConfig"][];
            /** @description Maximum number of edges per document (0 = unlimited) */
            max_edges_per_document?: number;
        };
        /**
         * @description The type of the index.
         * @enum {string}
         */
        IndexType: "full_text_v0" | "aknn_v0" | "graph_v0";
        /** @description Configuration for an index */
        IndexConfig: {
            /** @description Name of the index */
            name: string;
            /** @description Optional description of the index and its purpose */
            description?: string;
            type: components["schemas"]["IndexType"];
            /**
             * @description List of enrichment names to apply to documents before indexing. Enrichments must be defined at the table level.
             * @example [
             *       "semantic_chunks",
             *       "summary"
             *     ]
             */
            enrichments?: string[];
        } & (components["schemas"]["BleveIndexV2Config"] | components["schemas"]["EmbeddingIndexConfig"] | components["schemas"]["GraphIndexV0Config"]);
        /** @description Defines the structure of a document type */
        DocumentSchema: {
            /** @description A description of the document type. */
            description?: string;
            /**
             * @description A valid JSON Schema defining the document's structure.
             *     This is used to infer indexing rules and field types.
             */
            schema?: {
                [key: string]: unknown;
            };
        };
        /** @description Schema definition for a table with multiple document types */
        TableSchema: {
            /**
             * Format: uint32
             * @description Version of the schema. Used for migrations.
             */
            version?: number;
            /** @description Default type to use from the document_types. */
            default_type?: string;
            /**
             * @description Whether to enforce that documents must match one of the provided document types.
             *     If false, documents not matching any type will be accepted but not indexed.
             */
            enforce_types?: boolean;
            /** @description A map of type names to their document json schemas. */
            document_schemas?: {
                [key: string]: components["schemas"]["DocumentSchema"];
            };
            /**
             * @description The field containing the timestamp for TTL expiration (optional).
             *     Defaults to "_timestamp" if ttl_duration is specified but ttl_field is not.
             */
            ttl_field?: string;
            /**
             * @description The duration after which documents should expire, based on the ttl_field timestamp (optional).
             *     Uses Go duration format (e.g., '24h', '7d', '168h').
             */
            ttl_duration?: string;
        };
        BleveIndexV2Stats: {
            /** @description Error message if stats could not be retrieved */
            error?: string;
            /**
             * Format: uint64
             * @description Number of documents in the index
             */
            total_indexed?: number;
            /**
             * Format: uint64
             * @description Size of the index in bytes
             */
            disk_usage?: number;
            /** @description Whether the index is currently rebuilding */
            rebuilding?: boolean;
        };
        EmbeddingIndexStats: {
            /** @description Error message if stats could not be retrieved */
            error?: string;
            /**
             * Format: uint64
             * @description Number of vectors in the index
             */
            total_indexed?: number;
            /**
             * Format: uint64
             * @description Size of the index in bytes
             */
            disk_usage?: number;
            /**
             * Format: uint64
             * @description Total number of nodes in the index
             */
            total_nodes?: number;
        };
        /** @description Statistics for graph_v0 index */
        GraphIndexV0Stats: {
            /** @description Error message if stats could not be retrieved */
            error?: string;
            /**
             * Format: uint64
             * @description Total number of edges in the graph
             */
            total_edges?: number;
            /** @description Count of edges per edge type */
            edge_types?: {
                [key: string]: number;
            };
        };
        /** @description Statistics for an index */
        IndexStats: components["schemas"]["BleveIndexV2Stats"] | components["schemas"]["EmbeddingIndexStats"] | components["schemas"]["GraphIndexV0Stats"];
        User: {
            /** @example johndoe */
            username: string;
            /**
             * Format: byte
             * @description Base64 encoded password hash. Exposing this is a security risk.
             * @example JGFyZ29uMm...
             */
            password_hash: string;
        };
        /**
         * @description Type of the resource, e.g., table, user, or global ('*').
         * @example table
         * @enum {string}
         */
        ResourceType: "table" | "user" | "*";
        /**
         * @description Type of permission.
         * @example read
         * @enum {string}
         */
        PermissionType: "read" | "write" | "admin";
        Permission: {
            /**
             * @description Resource name (e.g., table name, target username, or '*' for global).
             * @example orders_table
             */
            resource: string;
            resource_type: components["schemas"]["ResourceType"];
            type: components["schemas"]["PermissionType"];
        };
        CreateUserRequest: {
            /**
             * @description Username for the new user. If provided in the path, this field can be omitted or must match the path parameter.
             * @example johndoe
             */
            username?: string;
            /**
             * Format: password
             * @example s3cr3tP@sswOrd
             */
            password: string;
            /** @description Optional list of initial permissions for the user. */
            initial_policies?: components["schemas"]["Permission"][] | null;
        };
        UpdatePasswordRequest: {
            /**
             * Format: password
             * @example newS3cr3tP@sswOrd
             */
            new_password: string;
        };
        SuccessMessage: {
            /** @example Operation completed successfully */
            message?: string;
        };
    };
    responses: {
        /** @description Bad request */
        BadRequest: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Resource not found */
        NotFound: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Internal server error */
        InternalServerError: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
    };
    parameters: {
        /** @description The username. */
        UserNamePathParameter: string;
    };
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    getStatus: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Cluster status retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ClusterStatus"];
                };
            };
            /** @description Unauthorized - authentication required */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            500: components["responses"]["InternalServerError"];
        };
    };
    globalQuery: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["QueryRequest"];
                "application/x-ndjson": string;
            };
        };
        responses: {
            /** @description Query successful */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["QueryResponses"];
                };
            };
            /** @description Invalid query request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    ragQuery: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RAGRequest"];
            };
        };
        responses: {
            /** @description RAG query successful, streaming summary or JSON response with citations and query results */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "text/event-stream": string;
                    "application/json": components["schemas"]["RAGResult"];
                };
            };
            /** @description Invalid RAG request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    answerAgent: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AnswerAgentRequest"];
            };
        };
        responses: {
            /** @description Answer agent successful, streaming events or JSON response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "text/event-stream": string;
                    "application/json": components["schemas"]["AnswerAgentResult"];
                };
            };
            /** @description Invalid answer agent request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    listTables: {
        parameters: {
            query?: {
                /**
                 * @description Filter tables by name prefix (e.g., "prod_")
                 * @example prod_
                 */
                prefix?: string;
                /**
                 * @description Filter tables by regex pattern (e.g., "^prod_.*_v[0-9]+$")
                 * @example ^user_.*
                 */
                pattern?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A list of tables */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TableStatus"][];
                };
            };
            400: components["responses"]["BadRequest"];
            500: components["responses"]["InternalServerError"];
        };
    };
    getTable: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the table */
                tableName: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Table details */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TableStatus"];
                };
            };
            404: components["responses"]["NotFound"];
        };
    };
    createTable: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the table */
                tableName: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateTableRequest"];
            };
        };
        responses: {
            /** @description Table created successfully with all configured indexes */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Table"];
                };
            };
            400: components["responses"]["BadRequest"];
        };
    };
    dropTable: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the table */
                tableName: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Table dropped successfully */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["BadRequest"];
            500: components["responses"]["InternalServerError"];
        };
    };
    queryTable: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the table to query */
                tableName: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["QueryRequest"];
                "application/x-ndjson": string;
            };
        };
        responses: {
            /** @description Query successful */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["QueryResponses"];
                };
            };
            400: components["responses"]["BadRequest"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    tableRagQuery: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the table for RAG query */
                tableName: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RAGRequest"];
            };
        };
        responses: {
            /** @description RAG query successful, streaming summary or JSON response with citations and query results */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "text/event-stream": string;
                    "application/json": components["schemas"]["RAGResult"];
                };
            };
            /** @description Invalid RAG request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            404: components["responses"]["NotFound"];
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    batch: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the table for batch operation */
                tableName: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["BatchRequest"];
            };
        };
        responses: {
            /** @description Batch operation successful */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description Number of documents successfully inserted */
                        inserted?: number;
                        /** @description Number of documents successfully deleted */
                        deleted?: number;
                        /** @description List of failed operations with error details */
                        failed?: {
                            /** @description The document ID that failed */
                            id?: string;
                            /** @description Error message for this failure */
                            error?: string;
                        }[];
                    };
                };
            };
            400: components["responses"]["BadRequest"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    linearMerge: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the table */
                tableName: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["LinearMergeRequest"];
            };
        };
        responses: {
            /** @description Merge completed successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LinearMergeResult"];
                };
            };
            400: components["responses"]["BadRequest"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    backupTable: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the table to backup */
                tableName: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["BackupRequest"];
            };
        };
        responses: {
            /** @description Backup process initiated successfully */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @example successful */
                        backup?: string;
                    };
                };
            };
            400: components["responses"]["BadRequest"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    restoreTable: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the table to restore into */
                tableName: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RestoreRequest"];
            };
        };
        responses: {
            /** @description Restore process triggered successfully */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @example triggered */
                        restore?: string;
                    };
                };
            };
            400: components["responses"]["BadRequest"];
            500: components["responses"]["InternalServerError"];
        };
    };
    updateSchema: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the table */
                tableName: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["TableSchema"];
            };
        };
        responses: {
            /** @description Schema updated successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Table"];
                };
            };
            400: components["responses"]["BadRequest"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    lookupKey: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the table */
                tableName: string;
                /** @description Key of the record to lookup */
                key: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Record found */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        [key: string]: unknown;
                    };
                };
            };
            400: components["responses"]["BadRequest"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    listIndexes: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the table */
                tableName: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A list of indexes for the table */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["IndexStatus"][];
                };
            };
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    getIndex: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the table */
                tableName: string;
                /** @description Name of the index */
                indexName: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Index details */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["IndexStatus"];
                };
            };
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    createIndex: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the table */
                tableName: string;
                /** @description Name of the index */
                indexName: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["IndexConfig"];
            };
        };
        responses: {
            /** @description Index added successfully */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["BadRequest"];
            500: components["responses"]["InternalServerError"];
        };
    };
    dropIndex: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the table */
                tableName: string;
                /** @description Name of the index */
                indexName: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Index dropped successfully */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["BadRequest"];
            500: components["responses"]["InternalServerError"];
        };
    };
    getCurrentUser: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @example johndoe */
                        username?: string;
                        permissions?: components["schemas"]["Permission"][];
                    };
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    listUsers: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @example johndoe */
                        username?: string;
                    }[];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Forbidden - requires admin permission */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    getUserByName: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The username. */
                userName: components["parameters"]["UserNamePathParameter"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["User"];
                };
            };
            /** @description Bad Request (e.g., username is required) */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description User not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    createUser: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The username. */
                userName: components["parameters"]["UserNamePathParameter"];
            };
            cookie?: never;
        };
        /** @description User creation details */
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateUserRequest"];
            };
        };
        responses: {
            /** @description User created successfully */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["User"];
                };
            };
            /** @description Bad Request (e.g., invalid input, username/password mismatch) */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Conflict (e.g., user already exists) */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    deleteUser: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The username. */
                userName: components["parameters"]["UserNamePathParameter"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description User deleted successfully */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Bad Request (e.g., username is required) */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description User not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    updateUserPassword: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The username. */
                userName: components["parameters"]["UserNamePathParameter"];
            };
            cookie?: never;
        };
        /** @description New password details */
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdatePasswordRequest"];
            };
        };
        responses: {
            /** @description Password updated successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SuccessMessage"];
                };
            };
            /** @description Bad Request (e.g., new password empty, username required) */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description User not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    getUserPermissions: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The username. */
                userName: components["parameters"]["UserNamePathParameter"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Permission"][];
                };
            };
            /** @description Bad Request (e.g., username is required) */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description User not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    addPermissionToUser: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The username. */
                userName: components["parameters"]["UserNamePathParameter"];
            };
            cookie?: never;
        };
        /** @description Permission details to add */
        requestBody: {
            content: {
                "application/json": components["schemas"]["Permission"];
            };
        };
        responses: {
            /** @description Permission added successfully */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SuccessMessage"];
                };
            };
            /** @description Bad Request (e.g., invalid input, username required) */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description User not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    removePermissionFromUser: {
        parameters: {
            query: {
                /** @description The name of the resource for the permission to be removed. */
                resource: string;
                /** @description The type of the resource for the permission to be removed. */
                resourceType: components["schemas"]["ResourceType"];
            };
            header?: never;
            path: {
                /** @description The username. */
                userName: components["parameters"]["UserNamePathParameter"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Permission removed successfully */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Bad Request (e.g., missing query parameters, invalid resourceType, username required) */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description User not found or Role not found for the given resource */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
}
