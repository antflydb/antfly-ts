/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/status": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get cluster status
         * @description Returns the current health and status of all stores and shards in the cluster
         */
        get: operations["getStatus"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/query": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Perform a global query
         * @description Executes a query across all relevant tables and shards based on the query content.
         *     IMPORTANT: The final line of data must end with a newline character \n. Each newline character may be preceded by a carriage return \r. When sending requests to this endpoint the Content-Type header should be set to application/x-ndjson.
         */
        post: operations["globalQuery"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/rag": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Perform RAG (Retrieval-Augmented Generation) query
         * @description Executes a query and streams a summary of the results using the specified summarizer. The response is streamed as Server-Sent Events (SSE) for real-time updates.
         */
        post: operations["ragQuery"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/agents/answer": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Answer Agent - Intelligent query routing with automatic query generation
         * @description Uses LLM to classify the query, generate optimal search queries across tables, execute them, and generate an answer (for questions) or return document IDs (for searches). Streams classification, keywords, generated queries, results, and answer as SSE events.
         */
        post: operations["answerAgent"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/table": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List all tables */
        get: operations["listTables"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/table/{tableName}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the table */
                tableName: string;
            };
            cookie?: never;
        };
        /** Get table details */
        get: operations["getTable"];
        put?: never;
        /** Create a new table */
        post: operations["createTable"];
        /** Drop a table */
        delete: operations["dropTable"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/table/{tableName}/query": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the table to query */
                tableName: string;
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Query a specific table */
        post: operations["queryTable"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/table/{tableName}/rag": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the table for RAG query */
                tableName: string;
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Perform RAG query on a specific table
         * @description Executes a RAG query on a specific table and streams a summary of the results using the specified summarizer. The response is streamed as Server-Sent Events (SSE) for real-time updates or returns JSON with citations.
         */
        post: operations["tableRagQuery"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/table/{tableName}/batch": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the table for batch operation */
                tableName: string;
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Perform batch inserts and deletes on a table */
        post: operations["batch"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/table/{tableName}/merge": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the table */
                tableName: string;
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Linear merge sorted records from external source
         * @description Performs a stateless linear merge of sorted records from an external source.
         *     Records are upserted, and any Antfly records in the key range that are absent
         *     from the input are deleted. Supports progressive pagination for large datasets.
         *
         *     WARNING: Not safe for concurrent merge operations with overlapping ranges.
         *     Designed as a sync/import API for single-client use.
         */
        post: operations["linearMerge"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/table/{tableName}/backup": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the table to backup */
                tableName: string;
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Backup a table */
        post: operations["backupTable"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/table/{tableName}/restore": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the table to restore into */
                tableName: string;
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Restore a table from backup */
        post: operations["restoreTable"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/table/{tableName}/schema": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the table */
                tableName: string;
            };
            cookie?: never;
        };
        get?: never;
        /** Update a table's schema */
        put: operations["updateSchema"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/table/{tableName}/key/{key}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the table */
                tableName: string;
                /** @description Key of the record to lookup */
                key: string;
            };
            cookie?: never;
        };
        /** Lookup a key in a table */
        get: operations["lookupKey"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/table/{tableName}/index": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the table */
                tableName: string;
            };
            cookie?: never;
        };
        /** List all indexes for a table */
        get: operations["listIndexes"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/table/{tableName}/index/{indexName}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the table */
                tableName: string;
                /** @description Name of the index */
                indexName: string;
            };
            cookie?: never;
        };
        /** Get index details */
        get: operations["getIndex"];
        put?: never;
        /** Add an index to a table */
        post: operations["createIndex"];
        /** Drop an index from a table */
        delete: operations["dropIndex"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/user/{userName}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The username. */
                userName: components["parameters"]["UserNamePathParameter"];
            };
            cookie?: never;
        };
        /**
         * Get user details
         * @description Retrieves details for a specific user.
         */
        get: operations["getUserByName"];
        put?: never;
        /**
         * Create a new user
         * @description Creates a new user with the given username and password. Username in path takes precedence.
         */
        post: operations["createUser"];
        /**
         * Delete a user
         * @description Deletes a specific user.
         */
        delete: operations["deleteUser"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/user/{userName}/password": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The username. */
                userName: components["parameters"]["UserNamePathParameter"];
            };
            cookie?: never;
        };
        get?: never;
        /**
         * Update user password
         * @description Updates the password for a specific user.
         */
        put: operations["updateUserPassword"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/user/{userName}/permission": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The username. */
                userName: components["parameters"]["UserNamePathParameter"];
            };
            cookie?: never;
        };
        /**
         * Get user permissions
         * @description Retrieves all permissions for a specific user.
         */
        get: operations["getUserPermissions"];
        put?: never;
        /**
         * Add permission to user
         * @description Adds a new permission to a specific user.
         */
        post: operations["addPermissionToUser"];
        /**
         * Remove permission from user
         * @description Removes a specific permission rule from a user based on resource name and type.
         */
        delete: operations["removePermissionFromUser"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        Error: {
            /** @example An error message */
            error: string;
        };
        /**
         * @description Overall health status of the cluster
         * @enum {string}
         */
        ClusterHealth: "unknown" | "healthy" | "unhealthy" | "degraded" | "error";
        ClusterStatus: {
            health: components["schemas"]["ClusterHealth"];
            /** @description Optional message providing details about the health status */
            message?: string;
        } & {
            [key: string]: unknown;
        };
        ByteRange: string[];
        ShardConfig: {
            byte_range: components["schemas"]["ByteRange"];
        };
        CreateTableRequest: {
            /** Format: uint */
            num_shards?: number;
            /**
             * @description Optional description of the table.
             * @example Table for user data
             */
            description?: string;
            indexes?: {
                [key: string]: components["schemas"]["IndexConfig"];
            };
            schema?: components["schemas"]["TableSchema"];
        };
        /** @enum {string} */
        AntflyType: "search_as_you_type" | "keyword" | "text" | "html" | "numeric" | "datetime" | "boolean" | "link" | "geopoint" | "geoshape" | "embedding" | "blob";
        Table: {
            name: string;
            /**
             * @description Optional description of the table.
             * @example Table for user data
             */
            description?: string;
            indexes: {
                [key: string]: components["schemas"]["IndexConfig"];
            };
            shards: {
                [key: string]: components["schemas"]["ShardConfig"];
            };
            schema?: components["schemas"]["TableSchema"];
        };
        DateRange: {
            name: string;
            from?: string;
            to?: string;
        };
        NumericRange: {
            name: string;
            /** Format: float */
            from?: number;
            /** Format: float */
            to?: number;
        };
        TermFacetResult: {
            term: string;
            count: number;
        };
        DateRangeResult: components["schemas"]["DateRange"] & {
            count: number;
        };
        NumericRangeResult: components["schemas"]["NumericRange"] & {
            count: number;
        };
        FacetOption: {
            field?: string;
            size?: number;
            date_ranges?: components["schemas"]["DateRange"][];
            numeric_ranges?: components["schemas"]["NumericRange"][];
        };
        FacetResult: {
            field?: string;
            total?: number;
            missing?: number;
            terms?: components["schemas"]["TermFacetResult"][];
            date_ranges?: components["schemas"]["DateRangeResult"][];
            numeric_ranges?: components["schemas"]["NumericRangeResult"][];
        };
        IndexStatus: {
            shard_status: {
                [key: string]: components["schemas"]["IndexStats"];
            };
            config: components["schemas"]["IndexConfig"];
            status: components["schemas"]["IndexStats"];
        };
        StorageStatus: {
            /**
             * Format: uint64
             * @description Disk usage in bytes.
             */
            disk_usage?: number;
            /** @description Whether the table has received data. */
            empty?: boolean;
        };
        TableStatus: components["schemas"]["Table"] & {
            storage_status: components["schemas"]["StorageStatus"];
        };
        /**
         * @example {
         *       "inserts": {
         *         "user:123": {
         *           "name": "John Doe",
         *           "email": "john@example.com",
         *           "age": 30,
         *           "tags": [
         *             "customer",
         *             "premium"
         *           ]
         *         },
         *         "user:456": {
         *           "name": "Jane Smith",
         *           "email": "jane@example.com",
         *           "age": 25,
         *           "tags": [
         *             "customer"
         *           ]
         *         }
         *       },
         *       "deletes": [
         *         "user:789",
         *         "user:old_account"
         *       ]
         *     }
         */
        BatchRequest: {
            inserts?: {
                [key: string]: Record<string, never>;
            };
            /** @description List of keys to delete. */
            deletes?: string[];
        };
        BackupRequest: {
            backup_id: string;
            /** @description Location for the backup (e.g., file:///path/to/backup, s3://bucket/path) */
            location: string;
        };
        RestoreRequest: components["schemas"]["BackupRequest"];
        RAGRequest: {
            /**
             * @description Array of retrieval queries to execute. Each query must specify a table and can specify its own limit and document_renderer.
             *     Results from all queries are concatenated together (respecting each query's limit).
             *     For single table: [{"table": "papers", "semantic_search": "...", "limit": 10}]
             *     For broadcast: [{"table": "images", "limit": 5, ...}, {"table": "products", "limit": 5, ...}]
             *     For mixed: [{"table": "papers", "semantic_search": "...", "limit": 10}, {"table": "books", "full_text_search": {...}, "limit": 5}]
             */
            queries: components["schemas"]["QueryRequest"][];
            summarizer: components["schemas"]["GeneratorConfig"];
            /**
             * @description Optional system prompt to guide the summarization
             * @example You are a helpful AI assistant. Summarize the following search results concisely.
             */
            system_prompt?: string;
            /** @description Enable SSE streaming of results instead of JSON response */
            with_streaming?: boolean;
        };
        /** @description RAG result with individual query results and summary */
        RAGResult: {
            /** @description Results from each query. Check each result's status and error fields for failures. */
            query_results?: components["schemas"]["QueryResult"][];
            summary_result?: components["schemas"]["SummarizeResult"];
        };
        AnswerAgentRequest: {
            /**
             * @description User's natural language query
             * @example What are the best gaming laptops under $2000?
             */
            query: string;
            summarizer: components["schemas"]["GeneratorConfig"];
            /**
             * @description Optional list of tables to search. If empty, searches all tables.
             * @example [
             *       "products",
             *       "reviews"
             *     ]
             */
            tables?: string[];
            /**
             * @description Optional list of indexes to use for each table. If empty, uses all available indexes.
             * @example [
             *       "embedding_idx",
             *       "search_idx"
             *     ]
             */
            indexes?: string[];
            /**
             * @description Optional system prompt to guide classification and answer generation
             * @example You are a helpful shopping assistant.
             */
            system_prompt?: string;
            /**
             * @description Enable SSE streaming of results (classification, keywords, queries, results, answer) instead of JSON response
             * @default true
             */
            with_streaming: boolean;
        };
        /** @description Answer agent result with classification, keywords, and generated answer or document IDs */
        AnswerAgentResult: {
            /**
             * @description Classification of the query type
             * @enum {string}
             */
            classification?: "question" | "search";
            /** @description Keywords extracted from the query */
            keywords?: string[];
            /** @description The queries that were generated and executed */
            queries_executed?: components["schemas"]["QueryRequest"][];
            /** @description Results from each generated query */
            query_results?: components["schemas"]["QueryResult"][];
            /** @description Generated answer for "question" classification (markdown format with inline document references) */
            answer?: string;
            /** @description Document IDs for "search" classification */
            document_ids?: string[];
        };
        QueryRequest: {
            table?: string;
            /** @description Full JSON Bleve search queries */
            full_text_search?: {
                [key: string]: unknown;
            };
            semantic_search?: string;
            indexes?: string[];
            /** Format: byte */
            filter_prefix?: string;
            /** @description Full JSON Bleve search queries */
            filter_query?: {
                [key: string]: unknown;
            };
            /** @description Full JSON Bleve search queries */
            exclusion_query?: {
                [key: string]: unknown;
            };
            facets?: {
                [key: string]: components["schemas"]["FacetOption"];
            };
            /** @description Raw embeddings to use for semantic searches (the keys are the indexes to use for the queries). */
            embeddings?: {
                [key: string]: number[];
            };
            /** @description List of fields to include in the results. */
            fields?: string[];
            /** @description Maximum number of results to return or topk for semantic_search. */
            limit?: number;
            /** @description Number of results to skip for pagination, only available for full_text_search queries. */
            offset?: number;
            order_by?: {
                [key: string]: boolean;
            };
            /**
             * Format: float
             * @description Maximum distance for semantic similarity search.
             */
            distance_under?: number;
            /**
             * Format: float
             * @description Minimum distance for semantic similarity search.
             */
            distance_over?: number;
            merge_strategy?: components["schemas"]["MergeStrategy"];
            count?: boolean;
            reranker?: components["schemas"]["RerankerConfig"];
            analyses?: components["schemas"]["Analyses"];
            /**
             * @description Optional Handlebars template string for rendering document content. Template has access to document fields via {{this.fields.fieldName}}
             * @example Title: {{this.fields.title}}
             *     Body: {{this.fields.body}}
             */
            document_renderer?: string;
        };
        Analyses: {
            pca?: boolean;
            tsne?: boolean;
        };
        AnalysesResult: {
            pca?: number[];
            tsne?: number[];
        };
        /** @description A single query result hit */
        QueryHit: {
            /** @description ID of the record. */
            _id: string;
            /**
             * Format: float
             * @description Relevance score of the hit.
             */
            _score: number;
            /** @description Scores partitioned by index when using RRF search. */
            _index_scores?: {
                [key: string]: unknown;
            };
            _source?: {
                [key: string]: unknown;
            };
        };
        /** @description A list of query hits. */
        QueryHits: {
            /**
             * Format: uint64
             * @description Total number of hits available.
             */
            total?: number;
            hits?: components["schemas"]["QueryHit"][];
            /**
             * Format: float
             * @description Maximum score of the results.
             */
            max_score?: number;
        };
        /** @description Responses from multiple query operations. */
        QueryResponses: {
            responses?: components["schemas"]["QueryResult"][];
        };
        /** @description Result of a query operation as an array of results and a count. */
        QueryResult: {
            hits?: components["schemas"]["QueryHits"];
            facets?: {
                [key: string]: components["schemas"]["FacetResult"];
            };
            /** @description Analysis results like PCA and t-SNE per index embeddings. */
            analyses?: {
                [key: string]: components["schemas"]["AnalysesResult"];
            };
            /**
             * Format: int64
             * @description Duration of the query in milliseconds.
             */
            took: number;
            /**
             * Format: int32
             * @description HTTP status code of the query operation.
             */
            status: number;
            /** @description Error message if the query failed. */
            error?: string;
            /** @description Which table this result came from */
            table?: string;
        };
        /**
         * @description Status of a linear merge page operation:
         *     - "success": All records in batch processed successfully
         *     - "partial": Processing stopped at shard boundary, client should retry with next_cursor
         *     - "error": Fatal error occurred, no records processed successfully
         * @enum {string}
         */
        LinearMergePageStatus: "success" | "partial" | "error";
        LinearMergeRequest: {
            /**
             * @description Map of document ID to document object: {"doc_id_1": {...}, "doc_id_2": {...}}
             *     Server will sort keys lexicographically before processing.
             *     This format avoids duplicate IDs (matches Antfly's batch write interface).
             */
            records: {
                [key: string]: unknown;
            };
            /**
             * @description ID of last record from previous merge request.
             *     Empty string "" for first request.
             *     Defines lower bound of key range to process.
             */
            last_merged_id?: string;
            /**
             * @description If true, return what would be deleted without making changes.
             *     Useful for validating sync behavior before committing.
             * @default false
             */
            dry_run: boolean;
        };
        FailedOperation: {
            id?: string;
            /** @enum {string} */
            operation?: "upsert" | "delete";
            error?: string;
        };
        /** @description Key range processed in this request */
        KeyRange: {
            from?: string;
            to?: string;
        };
        LinearMergeResult: {
            status: components["schemas"]["LinearMergePageStatus"];
            /** @description Records inserted or updated (0 if dry_run=true) */
            upserted: number;
            /** @description Records skipped because content hash matched (unchanged) */
            skipped: number;
            /** @description Records deleted or would be deleted (if dry_run=true) */
            deleted: number;
            /** @description IDs that were deleted (or would be deleted if dry_run=true). Only included if dry_run=true. */
            deleted_ids?: string[];
            failed?: components["schemas"]["FailedOperation"][];
            /** @description ID of last record in this batch (use for next request) */
            next_cursor: string;
            key_range?: components["schemas"]["KeyRange"];
            /** @description Total number of keys scanned from Antfly during range query */
            keys_scanned?: number;
            /** @description Additional information (e.g., "stopped at shard boundary", "dry run - no changes made") */
            message?: string;
            /** Format: int64 */
            took?: number;
        };
        /**
         * @description Merge strategy for combining results from the semantic_search and full_text_search.
         *     rrf: Reciprocal Rank Fusion
         *     failover: Use full_text_search if embedding generation fails
         * @default rrf
         * @enum {string}
         */
        MergeStrategy: "rrf" | "failover";
        /**
         * @description The embedding provider to use.
         * @enum {string}
         */
        EmbedderProvider: "gemini" | "ollama" | "openai" | "bedrock" | "mock";
        /** @description Configuration for the Google embedding provider. */
        GoogleEmbedderConfig: {
            /** @description The Google Cloud project ID. */
            project_id?: string;
            /** @description The Google Cloud location (e.g., 'us-central1'). */
            location?: string;
            /**
             * @description The name of the embedding model to use (e.g., 'text-embedding-004').
             * @default text-embedding-004
             */
            model: string;
            /**
             * @description The dimension of the embedding.
             * @default 1024
             */
            dimension: number;
            /** @description The Google API key. */
            api_key?: string;
            /**
             * Format: uri
             * @description The URL of the Google API endpoint.
             */
            url?: string;
        };
        /** @description Configuration for the Ollama embedding provider. */
        OllamaEmbedderConfig: {
            /** @description The name of the Ollama model to use. */
            model: string;
            /**
             * Format: uri
             * @description The URL of the Ollama API endpoint.
             */
            url?: string;
        };
        /** @description Configuration for the OpenAI embedding provider. */
        OpenAIEmbedderConfig: {
            /** @description The name of the OpenAI model to use. */
            model: string;
            /**
             * Format: uri
             * @description The URL of the OpenAI API endpoint.
             */
            url?: string;
            /** @description The OpenAI API key. */
            api_key?: string;
        };
        /** @description Configuration for the Bedrock embedding provider. */
        BedrockEmbedderConfig: {
            /**
             * @description The name of the Bedrock model to use.
             * @example amazon.titan-embed-text-v1
             */
            model: string;
            /** @description The AWS region for the Bedrock service. */
            region?: string;
            /** @description Whether to strip new lines from the input text. */
            strip_new_lines?: boolean;
            /** @description The batch size for embedding requests. */
            batch_size?: number;
        };
        /**
         * @description A unified configuration for an embedding provider.
         * @example {
         *       "provider": "openai",
         *       "model": "text-embedding-004",
         *       "field": "content"
         *     }
         */
        RerankerConfig: {
            provider: components["schemas"]["EmbedderProvider"];
            field?: string;
            template?: string;
        } & (components["schemas"]["GoogleEmbedderConfig"] | components["schemas"]["OllamaEmbedderConfig"] | components["schemas"]["OpenAIEmbedderConfig"] | components["schemas"]["BedrockEmbedderConfig"]);
        /** @description Configuration for the Google generative AI provider (Gemini). */
        GoogleGeneratorConfig: {
            /** @description The Google Cloud project ID. */
            project_id?: string;
            /** @description The Google Cloud location (e.g., 'us-central1'). */
            location?: string;
            /**
             * @description The name of the generative model to use (e.g., 'gemini-2.0-flash-exp', 'gemini-1.5-pro').
             * @default gemini-2.0-flash-exp
             */
            model: string;
            /**
             * Format: float
             * @description Controls randomness in generation (0.0-2.0).
             */
            temperature?: number;
            /** @description Maximum number of tokens to generate. */
            max_tokens?: number;
            /**
             * Format: float
             * @description Nucleus sampling parameter.
             */
            top_p?: number;
            /** @description Top-k sampling parameter. */
            top_k?: number;
            /** @description The Google API key. */
            api_key?: string;
            /**
             * Format: uri
             * @description The URL of the Google API endpoint.
             */
            url?: string;
        };
        /** @description Configuration for the Ollama generative AI provider. */
        OllamaGeneratorConfig: {
            /** @description The name of the Ollama model to use (e.g., 'llama3.2', 'llava'). */
            model: string;
            /**
             * Format: uri
             * @description The URL of the Ollama API endpoint.
             */
            url?: string;
            /**
             * Format: float
             * @description Controls randomness in generation (0.0-2.0).
             */
            temperature?: number;
            /** @description Maximum number of tokens to generate. */
            max_tokens?: number;
            /**
             * Format: float
             * @description Nucleus sampling parameter.
             */
            top_p?: number;
            /** @description Top-k sampling parameter. */
            top_k?: number;
        };
        /** @description Configuration for the OpenAI generative AI provider. */
        OpenAIGeneratorConfig: {
            /** @description The name of the OpenAI model to use (e.g., 'gpt-4o', 'gpt-4-turbo'). */
            model: string;
            /**
             * Format: uri
             * @description The URL of the OpenAI API endpoint.
             */
            url?: string;
            /** @description The OpenAI API key. */
            api_key?: string;
            /**
             * Format: float
             * @description Controls randomness in generation (0.0-2.0).
             */
            temperature?: number;
            /** @description Maximum number of tokens to generate. */
            max_tokens?: number;
            /**
             * Format: float
             * @description Nucleus sampling parameter.
             */
            top_p?: number;
            /**
             * Format: float
             * @description Penalty for token frequency (-2.0 to 2.0).
             */
            frequency_penalty?: number;
            /**
             * Format: float
             * @description Penalty for token presence (-2.0 to 2.0).
             */
            presence_penalty?: number;
        };
        /** @description Configuration for the AWS Bedrock generative AI provider. */
        BedrockGeneratorConfig: {
            /**
             * @description The name of the Bedrock model to use.
             * @example anthropic.claude-3-5-sonnet-20241022-v2:0
             */
            model: string;
            /** @description The AWS region for the Bedrock service. */
            region?: string;
            /**
             * Format: float
             * @description Controls randomness in generation (0.0-1.0).
             */
            temperature?: number;
            /** @description Maximum number of tokens to generate. */
            max_tokens?: number;
            /**
             * Format: float
             * @description Nucleus sampling parameter.
             */
            top_p?: number;
            /** @description Top-k sampling parameter. */
            top_k?: number;
        };
        /** @description Configuration for the Anthropic generative AI provider. */
        AnthropicGeneratorConfig: {
            /** @description The name of the Anthropic model to use (e.g., 'claude-3-5-sonnet-20241022'). */
            model: string;
            /** @description The Anthropic API key. */
            api_key?: string;
            /**
             * Format: uri
             * @description The URL of the Anthropic API endpoint.
             */
            url?: string;
            /**
             * Format: float
             * @description Controls randomness in generation (0.0-1.0).
             */
            temperature?: number;
            /** @description Maximum number of tokens to generate. */
            max_tokens?: number;
            /**
             * Format: float
             * @description Nucleus sampling parameter.
             */
            top_p?: number;
            /** @description Top-k sampling parameter. */
            top_k?: number;
        };
        /**
         * @description The generative AI provider to use.
         * @enum {string}
         */
        GeneratorProvider: "gemini" | "ollama" | "openai" | "bedrock" | "anthropic" | "mock";
        /**
         * @description A unified configuration for a generative AI provider.
         * @example {
         *       "provider": "openai",
         *       "model": "gpt-4o",
         *       "temperature": 0.7,
         *       "max_tokens": 2048
         *     }
         */
        GeneratorConfig: (components["schemas"]["GoogleGeneratorConfig"] | components["schemas"]["OllamaGeneratorConfig"] | components["schemas"]["OpenAIGeneratorConfig"] | components["schemas"]["BedrockGeneratorConfig"] | components["schemas"]["AnthropicGeneratorConfig"]) & {
            provider: components["schemas"]["GeneratorProvider"];
        };
        /** @description Result of a summarization operation. The summary is formatted as markdown with inline document references using [doc_id <id>] or [doc_id <id1>, <id2>] format. */
        SummarizeResult: {
            /** @description The generated summary text in markdown format with inline document references like [doc_id doc1] or [doc_id doc1, doc2] */
            summary: string;
        };
        BleveIndexV2Config: {
            /** @description Whether to use memory-only storage */
            mem_only?: boolean;
        };
        /**
         * @description A unified configuration for an embedding provider.
         * @example {
         *       "provider": "openai",
         *       "model": "text-embedding-004"
         *     }
         */
        EmbedderConfig: (components["schemas"]["GoogleEmbedderConfig"] | components["schemas"]["OllamaEmbedderConfig"] | components["schemas"]["OpenAIEmbedderConfig"] | components["schemas"]["BedrockEmbedderConfig"]) & {
            provider: components["schemas"]["EmbedderProvider"];
        };
        EmbeddingIndexConfig: {
            /** @description Vector dimension */
            dimension: number;
            /** @description Field to extract embeddings from */
            field?: string;
            /**
             * @description Handlebars template for generating prompts. See https://handlebarsjs.com/guide/ for more information.
             * @example Hello, {{#if (eq Name "John")}}Johnathan{{else}}{{Name}}{{/if}}! You are {{Age}} years old.
             */
            template?: string;
            /** @description Whether to use in-memory only storage */
            mem_only?: boolean;
            /** @description Configuration for the embeddings plugin */
            embedder?: components["schemas"]["EmbedderConfig"];
            /** @description Configuration for the generative AI plugin */
            summarizer?: components["schemas"]["GeneratorConfig"];
        };
        /**
         * @description The type of the index.
         * @enum {string}
         */
        IndexType: "full_text_v0" | "aknn_v0";
        /** @description Configuration for an index */
        IndexConfig: {
            /** @description Name of the index */
            name: string;
            type: components["schemas"]["IndexType"];
        } & (components["schemas"]["BleveIndexV2Config"] | components["schemas"]["EmbeddingIndexConfig"]);
        /** @description Defines the structure of a document type */
        DocumentSchema: {
            /** @description A description of the document type. */
            description?: string;
            /**
             * @description A valid JSON Schema defining the document's structure.
             *     This is used to infer indexing rules and field types.
             */
            schema?: {
                [key: string]: unknown;
            };
        };
        /** @description Schema definition for a table with multiple document types */
        TableSchema: {
            /**
             * Format: uint32
             * @description Version of the schema. Used for migrations.
             */
            version?: number;
            /** @description Default type to use from the document_types. */
            default_type?: string;
            /**
             * @description Whether to enforce that documents must match one of the provided document types.
             *     If false, documents not matching any type will be accepted but not indexed.
             */
            enforce_types?: boolean;
            /** @description A map of type names to their document json schemas. */
            document_schemas?: {
                [key: string]: components["schemas"]["DocumentSchema"];
            };
            /**
             * @description The field containing the timestamp for TTL expiration (optional).
             *     Defaults to "_timestamp" if ttl_duration is specified but ttl_field is not.
             */
            ttl_field?: string;
            /**
             * @description The duration after which documents should expire, based on the ttl_field timestamp (optional).
             *     Uses Go duration format (e.g., '24h', '7d', '168h').
             */
            ttl_duration?: string;
        };
        BleveIndexV2Stats: {
            /** @description Error message if stats could not be retrieved */
            error?: string;
            /**
             * Format: uint64
             * @description Number of documents in the index
             */
            total_indexed?: number;
            /**
             * Format: uint64
             * @description Size of the index in bytes
             */
            disk_usage?: number;
            /** @description Whether the index is currently rebuilding */
            rebuilding?: boolean;
        };
        EmbeddingIndexStats: {
            /** @description Error message if stats could not be retrieved */
            error?: string;
            /**
             * Format: uint64
             * @description Number of vectors in the index
             */
            total_indexed?: number;
            /**
             * Format: uint64
             * @description Size of the index in bytes
             */
            disk_usage?: number;
            /**
             * Format: uint64
             * @description Total number of nodes in the index
             */
            total_nodes?: number;
        };
        /** @description Statistics for an index */
        IndexStats: components["schemas"]["BleveIndexV2Stats"] | components["schemas"]["EmbeddingIndexStats"];
        User: {
            /** @example johndoe */
            username: string;
            /**
             * Format: byte
             * @description Base64 encoded password hash. Exposing this is a security risk.
             * @example JGFyZ29uMm...
             */
            password_hash: string;
        };
        /**
         * @description Type of the resource, e.g., table, user, or global ('*').
         * @example table
         * @enum {string}
         */
        ResourceType: "table" | "user" | "*";
        /**
         * @description Type of permission.
         * @example read
         * @enum {string}
         */
        PermissionType: "read" | "write" | "admin";
        Permission: {
            /**
             * @description Resource name (e.g., table name, target username, or '*' for global).
             * @example orders_table
             */
            resource: string;
            resource_type: components["schemas"]["ResourceType"];
            type: components["schemas"]["PermissionType"];
        };
        CreateUserRequest: {
            /**
             * @description Username for the new user. If provided in the path, this field can be omitted or must match the path parameter.
             * @example johndoe
             */
            username?: string;
            /**
             * Format: password
             * @example s3cr3tP@sswOrd
             */
            password: string;
            /** @description Optional list of initial permissions for the user. */
            initial_policies?: components["schemas"]["Permission"][] | null;
        };
        UpdatePasswordRequest: {
            /**
             * Format: password
             * @example newS3cr3tP@sswOrd
             */
            new_password: string;
        };
        SuccessMessage: {
            /** @example Operation completed successfully */
            message?: string;
        };
    };
    responses: {
        /** @description Bad request */
        BadRequest: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Resource not found */
        NotFound: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Internal server error */
        InternalServerError: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
    };
    parameters: {
        /** @description The username. */
        UserNamePathParameter: string;
    };
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    getStatus: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Cluster status retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ClusterStatus"];
                };
            };
            /** @description Unauthorized - authentication required */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            500: components["responses"]["InternalServerError"];
        };
    };
    globalQuery: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["QueryRequest"];
                "application/x-ndjson": string;
            };
        };
        responses: {
            /** @description Query successful */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["QueryResponses"];
                };
            };
            /** @description Invalid query request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    ragQuery: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RAGRequest"];
            };
        };
        responses: {
            /** @description RAG query successful, streaming summary or JSON response with citations and query results */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "text/event-stream": string;
                    "application/json": components["schemas"]["RAGResult"];
                };
            };
            /** @description Invalid RAG request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    answerAgent: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AnswerAgentRequest"];
            };
        };
        responses: {
            /** @description Answer agent successful, streaming events or JSON response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "text/event-stream": string;
                    "application/json": components["schemas"]["AnswerAgentResult"];
                };
            };
            /** @description Invalid answer agent request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    listTables: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A list of tables */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TableStatus"][];
                };
            };
            400: components["responses"]["BadRequest"];
            500: components["responses"]["InternalServerError"];
        };
    };
    getTable: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the table */
                tableName: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Table details */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TableStatus"];
                };
            };
            404: components["responses"]["NotFound"];
        };
    };
    createTable: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the table */
                tableName: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateTableRequest"];
            };
        };
        responses: {
            /** @description Table created successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Table"];
                };
            };
            400: components["responses"]["BadRequest"];
        };
    };
    dropTable: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the table */
                tableName: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Table dropped successfully */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["BadRequest"];
            500: components["responses"]["InternalServerError"];
        };
    };
    queryTable: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the table to query */
                tableName: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["QueryRequest"];
                "application/x-ndjson": string;
            };
        };
        responses: {
            /** @description Query successful */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["QueryResponses"];
                };
            };
            400: components["responses"]["BadRequest"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    tableRagQuery: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the table for RAG query */
                tableName: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RAGRequest"];
            };
        };
        responses: {
            /** @description RAG query successful, streaming summary or JSON response with citations and query results */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "text/event-stream": string;
                    "application/json": components["schemas"]["RAGResult"];
                };
            };
            /** @description Invalid RAG request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            404: components["responses"]["NotFound"];
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    batch: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the table for batch operation */
                tableName: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["BatchRequest"];
            };
        };
        responses: {
            /** @description Batch operation successful */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description Number of documents successfully inserted */
                        inserted?: number;
                        /** @description Number of documents successfully deleted */
                        deleted?: number;
                        /** @description List of failed operations with error details */
                        failed?: {
                            /** @description The document ID that failed */
                            id?: string;
                            /** @description Error message for this failure */
                            error?: string;
                        }[];
                    };
                };
            };
            400: components["responses"]["BadRequest"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    linearMerge: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the table */
                tableName: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["LinearMergeRequest"];
            };
        };
        responses: {
            /** @description Merge completed successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LinearMergeResult"];
                };
            };
            400: components["responses"]["BadRequest"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    backupTable: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the table to backup */
                tableName: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["BackupRequest"];
            };
        };
        responses: {
            /** @description Backup process initiated successfully */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @example successful */
                        backup?: string;
                    };
                };
            };
            400: components["responses"]["BadRequest"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    restoreTable: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the table to restore into */
                tableName: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RestoreRequest"];
            };
        };
        responses: {
            /** @description Restore process triggered successfully */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @example triggered */
                        restore?: string;
                    };
                };
            };
            400: components["responses"]["BadRequest"];
            500: components["responses"]["InternalServerError"];
        };
    };
    updateSchema: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the table */
                tableName: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["TableSchema"];
            };
        };
        responses: {
            /** @description Schema updated successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Table"];
                };
            };
            400: components["responses"]["BadRequest"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    lookupKey: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the table */
                tableName: string;
                /** @description Key of the record to lookup */
                key: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Record found */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        [key: string]: unknown;
                    };
                };
            };
            400: components["responses"]["BadRequest"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    listIndexes: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the table */
                tableName: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A list of indexes for the table */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["IndexStatus"][];
                };
            };
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    getIndex: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the table */
                tableName: string;
                /** @description Name of the index */
                indexName: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Index details */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["IndexStatus"];
                };
            };
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    createIndex: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the table */
                tableName: string;
                /** @description Name of the index */
                indexName: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["IndexConfig"];
            };
        };
        responses: {
            /** @description Index added successfully */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["BadRequest"];
            500: components["responses"]["InternalServerError"];
        };
    };
    dropIndex: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Name of the table */
                tableName: string;
                /** @description Name of the index */
                indexName: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Index dropped successfully */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["BadRequest"];
            500: components["responses"]["InternalServerError"];
        };
    };
    getUserByName: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The username. */
                userName: components["parameters"]["UserNamePathParameter"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["User"];
                };
            };
            /** @description Bad Request (e.g., username is required) */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description User not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    createUser: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The username. */
                userName: components["parameters"]["UserNamePathParameter"];
            };
            cookie?: never;
        };
        /** @description User creation details */
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateUserRequest"];
            };
        };
        responses: {
            /** @description User created successfully */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["User"];
                };
            };
            /** @description Bad Request (e.g., invalid input, username/password mismatch) */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Conflict (e.g., user already exists) */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    deleteUser: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The username. */
                userName: components["parameters"]["UserNamePathParameter"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description User deleted successfully */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Bad Request (e.g., username is required) */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description User not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    updateUserPassword: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The username. */
                userName: components["parameters"]["UserNamePathParameter"];
            };
            cookie?: never;
        };
        /** @description New password details */
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdatePasswordRequest"];
            };
        };
        responses: {
            /** @description Password updated successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SuccessMessage"];
                };
            };
            /** @description Bad Request (e.g., new password empty, username required) */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description User not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    getUserPermissions: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The username. */
                userName: components["parameters"]["UserNamePathParameter"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Permission"][];
                };
            };
            /** @description Bad Request (e.g., username is required) */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description User not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    addPermissionToUser: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The username. */
                userName: components["parameters"]["UserNamePathParameter"];
            };
            cookie?: never;
        };
        /** @description Permission details to add */
        requestBody: {
            content: {
                "application/json": components["schemas"]["Permission"];
            };
        };
        responses: {
            /** @description Permission added successfully */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SuccessMessage"];
                };
            };
            /** @description Bad Request (e.g., invalid input, username required) */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description User not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    removePermissionFromUser: {
        parameters: {
            query: {
                /** @description The name of the resource for the permission to be removed. */
                resource: string;
                /** @description The type of the resource for the permission to be removed. */
                resourceType: components["schemas"]["ResourceType"];
            };
            header?: never;
            path: {
                /** @description The username. */
                userName: components["parameters"]["UserNamePathParameter"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Permission removed successfully */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Bad Request (e.g., missing query parameters, invalid resourceType, username required) */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description User not found or Role not found for the given resource */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
}
