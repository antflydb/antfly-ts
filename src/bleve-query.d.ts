/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export type paths = Record<string, never>;
export type webhooks = Record<string, never>;
export interface components {
  schemas: {
    /**
     * Format: double
     * @description A floating-point number used to decrease or increase the relevance scores of a query.
     * @default 1
     */
    Boost: number | null;
    /** @description The fuzziness of the query. Can be an integer or "auto". */
    Fuzziness: number | "auto";
    GeoPoint: {
      /** Format: double */
      lon?: number;
      /** Format: double */
      lat?: number;
    };
    TermQuery: {
      term: string;
      field?: string;
      boost?: components["schemas"]["Boost"];
    };
    MatchQuery: {
      match: string;
      field?: string;
      analyzer?: string;
      boost?: components["schemas"]["Boost"];
      /** Format: int32 */
      prefix_length?: number;
      fuzziness?: components["schemas"]["Fuzziness"];
      /** @enum {string} */
      operator?: "or" | "and";
    };
    MatchPhraseQuery: {
      match_phrase: string;
      field?: string;
      analyzer?: string;
      boost?: components["schemas"]["Boost"];
      fuzziness?: components["schemas"]["Fuzziness"];
    };
    PhraseQuery: {
      terms: string[];
      field?: string;
      boost?: components["schemas"]["Boost"];
      fuzziness?: components["schemas"]["Fuzziness"];
    };
    MultiPhraseQuery: {
      terms: string[][];
      field?: string;
      boost?: components["schemas"]["Boost"];
      fuzziness?: components["schemas"]["Fuzziness"];
    };
    FuzzyQuery: {
      term: string;
      /** Format: int32 */
      prefix_length?: number;
      fuzziness?: components["schemas"]["Fuzziness"];
      field?: string;
      boost?: components["schemas"]["Boost"];
    };
    PrefixQuery: {
      prefix: string;
      field?: string;
      boost?: components["schemas"]["Boost"];
    };
    RegexpQuery: {
      regexp: string;
      field?: string;
      boost?: components["schemas"]["Boost"];
    };
    WildcardQuery: {
      wildcard: string;
      field?: string;
      boost?: components["schemas"]["Boost"];
    };
    QueryStringQuery: {
      query: string;
      boost?: components["schemas"]["Boost"];
    };
    NumericRangeQuery: {
      /** Format: double */
      min?: number | null;
      /** Format: double */
      max?: number | null;
      inclusive_min?: boolean | null;
      inclusive_max?: boolean | null;
      field?: string;
      boost?: components["schemas"]["Boost"];
    };
    TermRangeQuery: {
      min?: string | null;
      max?: string | null;
      inclusive_min?: boolean | null;
      inclusive_max?: boolean | null;
      field?: string;
      boost?: components["schemas"]["Boost"];
    };
    DateRangeStringQuery: {
      /** Format: date-time */
      start?: string;
      /** Format: date-time */
      end?: string;
      inclusive_start?: boolean | null;
      inclusive_end?: boolean | null;
      field?: string;
      boost?: components["schemas"]["Boost"];
      datetime_parser?: string;
    };
    BooleanQuery: {
      must?: components["schemas"]["ConjunctionQuery"];
      should?: components["schemas"]["DisjunctionQuery"];
      must_not?: components["schemas"]["DisjunctionQuery"];
      filter?: components["schemas"]["Query"];
      boost?: components["schemas"]["Boost"];
    };
    ConjunctionQuery: {
      conjuncts: components["schemas"]["Query"][];
      boost?: components["schemas"]["Boost"];
    };
    DisjunctionQuery: {
      disjuncts: components["schemas"]["Query"][];
      boost?: components["schemas"]["Boost"];
      /** Format: double */
      min?: number;
    };
    MatchAllQuery: {
      match_all: Record<string, never>;
      boost?: components["schemas"]["Boost"];
    };
    MatchNoneQuery: {
      match_none: Record<string, never>;
      boost?: components["schemas"]["Boost"];
    };
    DocIdQuery: {
      ids: string[];
      boost?: components["schemas"]["Boost"];
    };
    BoolFieldQuery: {
      bool: boolean;
      field?: string;
      boost?: components["schemas"]["Boost"];
    };
    IPRangeQuery: {
      cidr: string;
      field?: string;
      boost?: components["schemas"]["Boost"];
    };
    GeoBoundingBoxQuery: {
      /** @description [lon, lat] */
      top_left: number[];
      /** @description [lon, lat] */
      bottom_right: number[];
      field?: string;
      boost?: components["schemas"]["Boost"];
    };
    GeoDistanceQuery: {
      /** @description [lon, lat] */
      location: number[];
      /** @example 10km */
      distance: string;
      field?: string;
      boost?: components["schemas"]["Boost"];
    };
    GeoBoundingPolygonQuery: {
      polygon_points: components["schemas"]["GeoPoint"][];
      field?: string;
      boost?: components["schemas"]["Boost"];
    };
    /** @description A GeoJSON shape object. This is a simplified representation. */
    GeoShape: {
      type: string;
      coordinates: unknown[];
    };
    GeoShapeGeometry: {
      shape: components["schemas"]["GeoShape"];
      /** @enum {string} */
      relation: "intersects" | "contains" | "within";
    };
    GeoShapeQuery: {
      geometry: components["schemas"]["GeoShapeGeometry"];
      field?: string;
      boost?: components["schemas"]["Boost"];
    };
    Query:
      | components["schemas"]["TermQuery"]
      | components["schemas"]["MatchQuery"]
      | components["schemas"]["MatchPhraseQuery"]
      | components["schemas"]["PhraseQuery"]
      | components["schemas"]["MultiPhraseQuery"]
      | components["schemas"]["FuzzyQuery"]
      | components["schemas"]["PrefixQuery"]
      | components["schemas"]["RegexpQuery"]
      | components["schemas"]["WildcardQuery"]
      | components["schemas"]["QueryStringQuery"]
      | components["schemas"]["NumericRangeQuery"]
      | components["schemas"]["TermRangeQuery"]
      | components["schemas"]["DateRangeStringQuery"]
      | components["schemas"]["BooleanQuery"]
      | components["schemas"]["ConjunctionQuery"]
      | components["schemas"]["DisjunctionQuery"]
      | components["schemas"]["MatchAllQuery"]
      | components["schemas"]["MatchNoneQuery"]
      | components["schemas"]["DocIdQuery"]
      | components["schemas"]["BoolFieldQuery"]
      | components["schemas"]["IPRangeQuery"]
      | components["schemas"]["GeoBoundingBoxQuery"]
      | components["schemas"]["GeoDistanceQuery"]
      | components["schemas"]["GeoBoundingPolygonQuery"]
      | components["schemas"]["GeoShapeQuery"];
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}
export type $defs = Record<string, never>;
export type operations = Record<string, never>;
