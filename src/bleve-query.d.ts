/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export type paths = Record<string, never>;
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        /**
         * Format: double
         * @description A floating-point number used to decrease or increase the relevance scores of a query.
         * @default 1
         */
        Boost: number | null;
        /** @description The fuzziness of the query. Can be an integer or "auto". */
        Fuzziness: number | "auto";
        GeoPoint: {
            /** Format: double */
            lon?: number;
            /** Format: double */
            lat?: number;
        };
        TermQuery: {
            term: string;
            field?: string;
            boost?: components["schemas"]["Boost"];
        };
        MatchQuery: {
            match: string;
            field?: string;
            analyzer?: string;
            boost?: components["schemas"]["Boost"];
            /** Format: int32 */
            prefix_length?: number;
            fuzziness?: components["schemas"]["Fuzziness"];
            /** @enum {string} */
            operator?: "or" | "and";
        };
        MatchPhraseQuery: {
            match_phrase: string;
            field?: string;
            analyzer?: string;
            boost?: components["schemas"]["Boost"];
            fuzziness?: components["schemas"]["Fuzziness"];
        };
        PhraseQuery: {
            terms: string[];
            field?: string;
            boost?: components["schemas"]["Boost"];
            fuzziness?: components["schemas"]["Fuzziness"];
        };
        MultiPhraseQuery: {
            terms: string[][];
            field?: string;
            boost?: components["schemas"]["Boost"];
            fuzziness?: components["schemas"]["Fuzziness"];
        };
        FuzzyQuery: {
            term: string;
            /** Format: int32 */
            prefix_length?: number;
            fuzziness?: components["schemas"]["Fuzziness"];
            field?: string;
            boost?: components["schemas"]["Boost"];
        };
        PrefixQuery: {
            prefix: string;
            field?: string;
            boost?: components["schemas"]["Boost"];
        };
        RegexpQuery: {
            regexp: string;
            field?: string;
            boost?: components["schemas"]["Boost"];
        };
        WildcardQuery: {
            wildcard: string;
            field?: string;
            boost?: components["schemas"]["Boost"];
        };
        QueryStringQuery: {
            query: string;
            boost?: components["schemas"]["Boost"];
        };
        NumericRangeQuery: {
            /** Format: double */
            min?: number | null;
            /** Format: double */
            max?: number | null;
            inclusive_min?: boolean | null;
            inclusive_max?: boolean | null;
            field?: string;
            boost?: components["schemas"]["Boost"];
        };
        TermRangeQuery: {
            min?: string | null;
            max?: string | null;
            inclusive_min?: boolean | null;
            inclusive_max?: boolean | null;
            field?: string;
            boost?: components["schemas"]["Boost"];
        };
        DateRangeStringQuery: {
            /** Format: date-time */
            start?: string;
            /** Format: date-time */
            end?: string;
            inclusive_start?: boolean | null;
            inclusive_end?: boolean | null;
            field?: string;
            boost?: components["schemas"]["Boost"];
            datetime_parser?: string;
        };
        BooleanQuery: {
            must?: components["schemas"]["ConjunctionQuery"];
            should?: components["schemas"]["DisjunctionQuery"];
            must_not?: components["schemas"]["DisjunctionQuery"];
            filter?: components["schemas"]["Query"];
            boost?: components["schemas"]["Boost"];
        };
        ConjunctionQuery: {
            conjuncts: components["schemas"]["Query"][];
            boost?: components["schemas"]["Boost"];
        };
        DisjunctionQuery: {
            disjuncts: components["schemas"]["Query"][];
            boost?: components["schemas"]["Boost"];
            /** Format: double */
            min?: number;
        };
        MatchAllQuery: {
            match_all: Record<string, never>;
            boost?: components["schemas"]["Boost"];
        };
        MatchNoneQuery: {
            match_none: Record<string, never>;
            boost?: components["schemas"]["Boost"];
        };
        DocIdQuery: {
            ids: string[];
            boost?: components["schemas"]["Boost"];
        };
        BoolFieldQuery: {
            bool: boolean;
            field?: string;
            boost?: components["schemas"]["Boost"];
        };
        IPRangeQuery: {
            cidr: string;
            field?: string;
            boost?: components["schemas"]["Boost"];
        };
        GeoBoundingBoxQuery: {
            /** @description [lon, lat] */
            top_left: number[];
            /** @description [lon, lat] */
            bottom_right: number[];
            field?: string;
            boost?: components["schemas"]["Boost"];
        };
        GeoDistanceQuery: {
            /** @description [lon, lat] */
            location: number[];
            /** @example 10km */
            distance: string;
            field?: string;
            boost?: components["schemas"]["Boost"];
        };
        GeoBoundingPolygonQuery: {
            polygon_points: components["schemas"]["GeoPoint"][];
            field?: string;
            boost?: components["schemas"]["Boost"];
        };
        /** @description A GeoJSON shape object. This is a simplified representation. */
        GeoShape: {
            type: string;
            coordinates: unknown[];
        };
        GeoShapeGeometry: {
            shape: components["schemas"]["GeoShape"];
            /** @enum {string} */
            relation: "intersects" | "contains" | "within";
        };
        GeoShapeQuery: {
            geometry: components["schemas"]["GeoShapeGeometry"];
            field?: string;
            boost?: components["schemas"]["Boost"];
        };
        Query: components["schemas"]["TermQuery"] | components["schemas"]["MatchQuery"] | components["schemas"]["MatchPhraseQuery"] | components["schemas"]["PhraseQuery"] | components["schemas"]["MultiPhraseQuery"] | components["schemas"]["FuzzyQuery"] | components["schemas"]["PrefixQuery"] | components["schemas"]["RegexpQuery"] | components["schemas"]["WildcardQuery"] | components["schemas"]["QueryStringQuery"] | components["schemas"]["NumericRangeQuery"] | components["schemas"]["TermRangeQuery"] | components["schemas"]["DateRangeStringQuery"] | components["schemas"]["BooleanQuery"] | components["schemas"]["ConjunctionQuery"] | components["schemas"]["DisjunctionQuery"] | components["schemas"]["MatchAllQuery"] | components["schemas"]["MatchNoneQuery"] | components["schemas"]["DocIdQuery"] | components["schemas"]["BoolFieldQuery"] | components["schemas"]["IPRangeQuery"] | components["schemas"]["GeoBoundingBoxQuery"] | components["schemas"]["GeoDistanceQuery"] | components["schemas"]["GeoBoundingPolygonQuery"] | components["schemas"]["GeoShapeQuery"];
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export type operations = Record<string, never>;
